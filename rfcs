[H[2J[H[2Jtermsaver.rfc: Connecting to http://tools.ietf.org/rfc/rfc1157.txt ... (this could take a while)






Network Working Group                                            J. Case
Request for Comments:  1157                                SNMP Research
Obsoletes:  RFC 1098                                            M. Fedor
                                       Performance Systems International
                                                          M. Schoffstall
                                       Performance Systems International
                                                                J. Davin
                                     MIT Laboratory for Computer Science
                                                                May 1990


              A Simple Network Management Protocol (SNMP)

                           Table of Contents

   1. Status of this Memo ...................................    2
   2. Introduction ..........................................    2
   3. The SNMP Architecture .................................    5
   3.1 Goals of the Architecture ............................    5
   3.2 Elements of the Architecture .........................    5
   3.2.1 Scope of Management Information ....................    6
   3.2.2 Representation of Management Information ...........    6
   3.2.3 Operations Supported on Management Information .....    7
   3.2.4 Form and Meaning of Protocol Exchanges .............    8
   3.2.5 Definition of Administrative Relationships .........    8
   3.2.6 Form and Meaning of References to Managed Objects ..   12
   3.2.6.1 Resolution of Ambiguous MIB References ...........   12
   3.2.6.2 Resolution of References across MIB Versions......   12
   3.2.6.3 Identification of Object Instances ...............   12
   3.2.6.3.1 ifTable Object Type Names ......................   13
   3.2.6.3.2 atTable Object Type Names ......................   13
   3.2.6.3.3 ipAddrTable Object Type Names ..................   14
   3.2.6.3.4 ipRoutingTable Object Type Names ...............   14
   3.2.6.3.5 tcpConnTable Object Type Names .................   14
   3.2.6.3.6 egpNeighTable Object Type Names ................   15
   4. Protocol Specification ................................   16
   4.1 Elements of Procedure ................................   17
   4.1.1 Common Constructs ..................................   19
   4.1.2 The GetRequest-PDU .................................   20
   4.1.3 The GetNextRequest-PDU .............................   21
   4.1.3.1 Example of Table Traversal .......................   23
   4.1.4 The GetResponse-PDU ................................   24
   4.1.5 The SetRequest-PDU .................................   25
   4.1.6 The Trap-PDU .......................................   27
   4.1.6.1 The coldStart Trap ...............................   28
   4.1.6.2 The warmStart Trap ...............................   28
   4.1.6.3 The linkDown Trap ................................   28
   4.1.6.4 The linkUp Trap ..................................   28



Case, Fedor, Schoffstall, & Davin                               [Page 1]

RFC 1157                          SNMP                          May 1990


   4.1.6.5 The authenticationFailure Trap ...................   28
   4.1.6.6 The egpNeighborLoss Trap .........................   28
   4.1.6.7 The enterpriseSpecific Trap ......................   29
   5. Definitions ...........................................   30
   6. Acknowledgements ......................................   33
   7. References ............................................   34
   8. Security Considerations................................   35
   9. Authors' Addresses.....................................   35

1.  Status of this Memo

   This RFC is a re-release of RFC 1098, with a changed "Status of this
   Memo" section plus a few minor typographical corrections.  This memo
   defines a simple protocol by which management information for a
   network element may be inspected or altered by logically remote
   users.  In particular, together with its companion memos which
   describe the structure of management information along with the
   management information base, these documents provide a simple,
   workable architecture and system for managing TCP/IP-based internets
   and in particular the Internet.

   The Internet Activities Board recommends that all IP and TCP
   implementations be network manageable.  This implies implementation
   of the Internet MIB (RFC-1156) and at least one of the two
   recommended management protocols SNMP (RFC-1157) or CMOT (RFC-1095).
   It should be noted that, at this time, SNMP is a full Internet
   standard and CMOT is a draft standard.  See also the Host and Gateway
   Requirements RFCs for more specific information on the applicability
   of this standard.

   Please refer to the latest edition of the "IAB Official Protocol
   Standards" RFC for current information on the state and status of
   standard Internet protocols.

   Distribution of this memo is unlimited.

2.  Introduction

   As reported in RFC 1052, IAB Recommendations for the Development of
   Internet Network Management Standards [1], a two-prong strategy for
   network management of TCP/IP-based internets was undertaken.  In the
   short-term, the Simple Network Management Protocol (SNMP) was to be
   used to manage nodes in the Internet community.  In the long-term,
   the use of the OSI network management framework was to be examined.
   Two documents were produced to define the management information: RFC
   1065, which defined the Structure of Management Information (SMI)
   [2], and RFC 1066, which defined the Management Information Base
   (MIB) [3].  Both of these documents were designed so as to be



Case, Fedor, Schoffstall, & Davin                               [Page 2]

RFC 1157                          SNMP                          May 1990


   compatible with both the SNMP and the OSI network management
   framework.

   This strategy was quite successful in the short-term: Internet-based
   network management technology was fielded, by both the research and
   commercial communities, within a few months.  As a result of this,
   portions of the Internet community became network manageable in a
   timely fashion.

   As reported in RFC 1109, Report of the Second Ad Hoc Network
   Management Review Group [4], the requirements of the SNMP and the OSI
   network management frameworks were more different than anticipated.
   As such, the requirement for compatibility between the SMI/MIB and
   both frameworks was suspended.  This action permitted the operational
   network management framework, the SNMP, to respond to new operational
   needs in the Internet community by producing documents defining new
   MIB items.

   The IAB has designated the SNMP, SMI, and the initial Internet MIB to
   be full "Standard Protocols" with "Recommended" status.  By this
   action, the IAB recommends that all IP and TCP implementations be
   network manageable and that the implementations that are network
   manageable are expected to adopt and implement the SMI, MIB, and
   SNMP.

   As such, the current network management framework for TCP/IP- based
   internets consists of:  Structure and Identification of Management
   Information for TCP/IP-based Internets, which describes how managed
   objects contained in the MIB are defined as set forth in RFC 1155
   [5]; Management Information Base for Network Management of TCP/IP-
   based Internets, which describes the managed objects contained in the
   MIB as set forth in RFC 1156 [6]; and, the Simple Network Management
   Protocol, which defines the protocol used to manage these objects, as
   set forth in this memo.

   As reported in RFC 1052, IAB Recommendations for the Development of
   Internet Network Management Standards [1], the Internet Activities
   Board has directed the Internet Engineering Task Force (IETF) to
   create two new working groups in the area of network management.  One
   group was charged with the further specification and definition of
   elements to be included in the Management Information Base (MIB).
   The other was charged with defining the modifications to the Simple
   Network Management Protocol (SNMP) to accommodate the short-term
   needs of the network vendor and operations communities, and to align
   with the output of the MIB working group.

   The MIB working group produced two memos, one which defines a
   Structure for Management Information (SMI) [2] for use by the managed



Case, Fedor, Schoffstall, & Davin                               [Page 3]

RFC 1157                          SNMP                          May 1990


   objects contained in the MIB.  A second memo [3] defines the list of
   managed objects.

   The output of the SNMP Extensions working group is this memo, which
   incorporates changes to the initial SNMP definition [7] required to
   attain alignment with the output of the MIB working group.  The
   changes should be minimal in order to be consistent with the IAB's
   directive that the working groups be "extremely sensitive to the need
   to keep the SNMP simple."  Although considerable care and debate has
   gone into the changes to the SNMP which are reflected in this memo,
   the resulting protocol is not backwardly-compatible with its
   predecessor, the Simple Gateway Monitoring Protocol (SGMP) [8].
   Although the syntax of the protocol has been altered, the original
   philosophy, design decisions, and architecture remain intact.  In
   order to avoid confusion, new UDP ports have been allocated for use
   by the protocol described in this memo.



































Case, Fedor, Schoffstall, & Davin                               [Page 4]

RFC 1157                          SNMP                          May 1990


3.  The SNMP Architecture

   Implicit in the SNMP architectural model is a collection of network
   management stations and network elements.  Network management
   stations execute management applications which monitor and control
   network elements.  Network elements are devices such as hosts,
   gateways, terminal servers, and the like, which have management
   agents responsible for performing the network management functions
   requested by the network management stations.  The Simple Network
   Management Protocol (SNMP) is used to communicate management
   information between the network management stations and the agents in
   the network elements.

3.1.  Goals of the Architecture

   The SNMP explicitly minimizes the number and complexity of management
   functions realized by the management agent itself.  This goal is
   attractive in at least four respects:

      (1)  The development cost for management agent software
           necessary to support the protocol is accordingly reduced.

      (2)  The degree of management function that is remotely
           supported is accordingly increased, thereby admitting
           fullest use of internet resources in the management task.

      (3)  The degree of management function that is remotely
           supported is accordingly increased, thereby imposing the
           fewest possible restrictions on the form and
           sophistication of management tools.

      (4)  Simplified sets of management functions are easily
           understood and used by developers of network management
           tools.

   A second goal of the protocol is that the functional paradigm for
   monitoring and control be sufficiently extensible to accommodate
   additional, possibly unanticipated aspects of network operation and
   management.

   A third goal is that the architecture be, as much as possible,
   independent of the architecture and mechanisms of particular hosts or
   particular gateways.

3.2.  Elements of the Architecture

   The SNMP architecture articulates a solution to the network
   management problem in terms of:



Case, Fedor, Schoffstall, & Davin                               [Page 5]

RFC 1157                          SNMP                          May 1990


      (1)  the scope of the management information communicated by
           the protocol,

      (2)  the representation of the management information
           communicated by the protocol,

      (3)  operations on management information supported by the
           protocol,

      (4)  the form and meaning of exchanges among management
           entities,

      (5)  the definition of administrative relationships among
           management entities, and

      (6)  the form and meaning of references to management
           information.

3.2.1.  Scope of Management Information

   The scope of the management information communicated by operation of
   the SNMP is exactly that represented by instances of all non-
   aggregate object types either defined in Internet-standard MIB or
   defined elsewhere according to the conventions set forth in
   Internet-standard SMI [5].

   Support for aggregate object types in the MIB is neither required for
   conformance with the SMI nor realized by the SNMP.

3.2.2.  Representation of Management Information

   Management information communicated by operation of the SNMP is
   represented according to the subset of the ASN.1 language [9] that is
   specified for the definition of non-aggregate types in the SMI.

   The SGMP adopted the convention of using a well-defined subset of the
   ASN.1 language [9].  The SNMP continues and extends this tradition by
   utilizing a moderately more complex subset of ASN.1 for describing
   managed objects and for describing the protocol data units used for
   managing those objects.  In addition, the desire to ease eventual
   transition to OSI-based network management protocols led to the
   definition in the ASN.1 language of an Internet-standard Structure of
   Management Information (SMI) [5] and Management Information Base
   (MIB) [6].  The use of the ASN.1 language, was, in part, encouraged
   by the successful use of ASN.1 in earlier efforts, in particular, the
   SGMP.  The restrictions on the use of ASN.1 that are part of the SMI
   contribute to the simplicity espoused and validated by experience
   with the SGMP.



Case, Fedor, Schoffstall, & Davin                               [Page 6]

RFC 1157                          SNMP                          May 1990


   Also for the sake of simplicity, the SNMP uses only a subset of the
   basic encoding rules of ASN.1 [10].  Namely, all encodings use the
   definite-length form.  Further, whenever permissible, non-constructor
   encodings are used rather than constructor encodings.  This
   restriction applies to all aspects of ASN.1 encoding, both for the
   top-level protocol data units and the data objects they contain.

3.2.3.  Operations Supported on Management Information

   The SNMP models all management agent functions as alterations or
   inspections of variables.  Thus, a protocol entity on a logically
   remote host (possibly the network element itself) interacts with the
   management agent resident on the network element in order to retrieve
   (get) or alter (set) variables.  This strategy has at least two
   positive consequences:

      (1)  It has the effect of limiting the number of essential
           management functions realized by the management agent to
           two:  one operation to assign a value to a specified
           configuration or other parameter and another to retrieve
           such a value.

      (2)  A second effect of this decision is to avoid introducing
           into the protocol definition support for imperative
           management commands:  the number of such commands is in
           practice ever-increasing, and the semantics of such
           commands are in general arbitrarily complex.

   The strategy implicit in the SNMP is that the monitoring of network
   state at any significant level of detail is accomplished primarily by
   polling for appropriate information on the part of the monitoring
   center(s).  A limited number of unsolicited messages (traps) guide
   the timing and focus of the polling.  Limiting the number of
   unsolicited messages is consistent with the goal of simplicity and
   minimizing the amount of traffic generated by the network management
   function.

   The exclusion of imperative commands from the set of explicitly
   supported management functions is unlikely to preclude any desirable
   management agent operation.  Currently, most commands are requests
   either to set the value of some parameter or to retrieve such a
   value, and the function of the few imperative commands currently
   supported is easily accommodated in an asynchronous mode by this
   management model.  In this scheme, an imperative command might be
   realized as the setting of a parameter value that subsequently
   triggers the desired action.  For example, rather than implementing a
   "reboot command," this action might be invoked by simply setting a
   parameter indicating the number of seconds until system reboot.



Case, Fedor, Schoffstall, & Davin                               [Page 7]

RFC 1157                          SNMP                          May 1990


3.2.4.  Form and Meaning of Protocol Exchanges

   The communication of management information among management entities
   is realized in the SNMP through the exchange of protocol messages.
   The form and meaning of those messages is defined below in Section 4.

   Consistent with the goal of minimizing complexity of the management
   agent, the exchange of SNMP messages requires only an unreliable
   datagram service, and every message is entirely and independently
   represented by a single transport datagram.  While this document
   specifies the exchange of messages via the UDP protocol [11], the
   mechanisms of the SNMP are generally suitable for use with a wide
   variety of transport services.

3.2.5.  Definition of Administrative Relationships

   The SNMP architecture admits a variety of administrative
   relationships among entities that participate in the protocol.  The
   entities residing at management stations and network elements which
   communicate with one another using the SNMP are termed SNMP
   application entities.  The peer processes which implement the SNMP,
   and thus support the SNMP application entities, are termed protocol
   entities.

   A pairing of an SNMP agent with some arbitrary set of SNMP
   application entities is called an SNMP community.  Each SNMP
   community is named by a string of octets, that is called the
   community name for said community.

   An SNMP message originated by an SNMP application entity that in fact
   belongs to the SNMP community named by the community component of
   said message is called an authentic SNMP message.  The set of rules
   by which an SNMP message is identified as an authentic SNMP message
   for a particular SNMP community is called an authentication scheme.
   An implementation of a function that identifies authentic SNMP
   messages according to one or more authentication schemes is called an
   authentication service.

   Clearly, effective management of administrative relationships among
   SNMP application entities requires authentication services that (by
   the use of encryption or other techniques) are able to identify
   authentic SNMP messages with a high degree of certainty.  Some SNMP
   implementations may wish to support only a trivial authentication
   service that identifies all SNMP messages as authentic SNMP messages.

   For any network element, a subset of objects in the MIB that pertain
   to that element is called a SNMP MIB view.  Note that the names of
   the object types represented in a SNMP MIB view need not belong to a



Case, Fedor, Schoffstall, & Davin                               [Page 8]

RFC 1157                          SNMP                          May 1990


   single sub-tree of the object type name space.

   An element of the set { READ-ONLY, READ-WRITE } is called an SNMP
   access mode.

   A pairing of a SNMP access mode with a SNMP MIB view is called an
   SNMP community profile.  A SNMP community profile represents
   specified access privileges to variables in a specified MIB view. For
   every variable in the MIB view in a given SNMP community profile,
   access to that variable is represented by the profile according to
   the following conventions:

      (1)  if said variable is defined in the MIB with "Access:" of
           "none," it is unavailable as an operand for any operator;

      (2)  if said variable is defined in the MIB with "Access:" of
           "read-write" or "write-only" and the access mode of the
           given profile is READ-WRITE, that variable is available
           as an operand for the get, set, and trap operations;

      (3)  otherwise, the variable is available as an operand for
           the get and trap operations.

      (4)  In those cases where a "write-only" variable is an
           operand used for the get or trap operations, the value
           given for the variable is implementation-specific.

   A pairing of a SNMP community with a SNMP community profile is called
   a SNMP access policy. An access policy represents a specified
   community profile afforded by the SNMP agent of a specified SNMP
   community to other members of that community.  All administrative
   relationships among SNMP application entities are architecturally
   defined in terms of SNMP access policies.

   For every SNMP access policy, if the network element on which the
   SNMP agent for the specified SNMP community resides is not that to
   which the MIB view for the specified profile pertains, then that
   policy is called a SNMP proxy access policy. The SNMP agent
   associated with a proxy access policy is called a SNMP proxy agent.
   While careless definition of proxy access policies can result in
   management loops, prudent definition of proxy policies is useful in
   at least two ways:

      (1)  It permits the monitoring and control of network elements
           which are otherwise not addressable using the management
           protocol and the transport protocol.  That is, a proxy
           agent may provide a protocol conversion function allowing
           a management station to apply a consistent management



Case, Fedor, Schoffstall, & Davin                               [Page 9]

RFC 1157                          SNMP                          May 1990


           framework to all network elements, including devices such
           as modems, multiplexors, and other devices which support
           different management frameworks.

      (2)  It potentially shields network elements from elaborate
           access control policies.  For example, a proxy agent may
           implement sophisticated access control whereby diverse
           subsets of variables within the MIB are made accessible
           to different management stations without increasing the
           complexity of the network element.

   By way of example, Figure 1 illustrates the relationship between
   management stations, proxy agents, and management agents.  In this
   example, the proxy agent is envisioned to be a normal Internet
   Network Operations Center (INOC) of some administrative domain which
   has a standard managerial relationship with a set of management
   agents.


































Case, Fedor, Schoffstall, & Davin                              [Page 10]

RFC 1157                          SNMP                          May 1990


   +------------------+       +----------------+      +----------------+
   |  Region #1 INOC  |       |Region #2 INOC  |      |PC in Region #3 |
   |                  |       |                |      |                |
   |Domain=Region #1  |       |Domain=Region #2|      |Domain=Region #3|
   |CPU=super-mini-1  |       |CPU=super-mini-1|      |CPU=Clone-1     |
   |PCommunity=pub    |       |PCommunity=pub  |      |PCommunity=slate|
   |                  |       |                |      |                |
   +------------------+       +----------------+      +----------------+
          /|\                      /|\                     /|\
           |                        |                       |
           |                        |                       |
           |                       \|/                      |
           |               +-----------------+              |
           +-------------->| Region #3 INOC  |<-------------+
                           |                 |
                           |Domain=Region #3 |
                           |CPU=super-mini-2 |
                           |PCommunity=pub,  |
                           |         slate   |
                           |DCommunity=secret|
           +-------------->|                 |<-------------+
           |               +-----------------+              |
           |                       /|\                      |
           |                        |                       |
           |                        |                       |
          \|/                      \|/                     \|/
   +-----------------+     +-----------------+       +-----------------+
   |Domain=Region#3  |     |Domain=Region#3  |       |Domain=Region#3  |
   |CPU=router-1     |     |CPU=mainframe-1  |       |CPU=modem-1      |
   |DCommunity=secret|     |DCommunity=secret|       |DCommunity=secret|
   +-----------------+     +-----------------+       +-----------------+


   Domain:  the administrative domain of the element
   PCommunity:  the name of a community utilizing a proxy agent
   DCommunity:  the name of a direct community


                                 Figure 1
                 Example Network Management Configuration











Case, Fedor, Schoffstall, & Davin                              [Page 11]

RFC 1157                          SNMP                          May 1990


3.2.6.  Form and Meaning of References to Managed Objects

   The SMI requires that the definition of a conformant management
   protocol address:

      (1)  the resolution of ambiguous MIB references,

      (2)  the resolution of MIB references in the presence multiple
           MIB versions, and

      (3)  the identification of particular instances of object
           types defined in the MIB.

3.2.6.1.  Resolution of Ambiguous MIB References

   Because the scope of any SNMP operation is conceptually confined to
   objects relevant to a single network element, and because all SNMP
   references to MIB objects are (implicitly or explicitly) by unique
   variable names, there is no possibility that any SNMP reference to
   any object type defined in the MIB could resolve to multiple
   instances of that type.

3.2.6.2.  Resolution of References across MIB Versions

   The object instance referred to by any SNMP operation is exactly that
   specified as part of the operation request or (in the case of a get-
   next operation) its immediate successor in the MIB as a whole.  In
   particular, a reference to an object as part of some version of the
   Internet-standard MIB does not resolve to any object that is not part
   of said version of the Internet-standard MIB, except in the case that
   the requested operation is get-next and the specified object name is
   lexicographically last among the names of all objects presented as
   part of said version of the Internet-Standard MIB.

3.2.6.3.  Identification of Object Instances

   The names for all object types in the MIB are defined explicitly
   either in the Internet-standard MIB or in other documents which
   conform to the naming conventions of the SMI.  The SMI requires that
   conformant management protocols define mechanisms for identifying
   individual instances of those object types for a particular network
   element.

   Each instance of any object type defined in the MIB is identified in
   SNMP operations by a unique name called its "variable name." In
   general, the name of an SNMP variable is an OBJECT IDENTIFIER of the
   form x.y, where x is the name of a non-aggregate object type defined
   in the MIB and y is an OBJECT IDENTIFIER fragment that, in a way



Case, Fedor, Schoffstall, & Davin                              [Page 12]

RFC 1157                          SNMP                          May 1990


   specific to the named object type, identifies the desired instance.

   This naming strategy admits the fullest exploitation of the semantics
   of the GetNextRequest-PDU (see Section 4), because it assigns names
   for related variables so as to be contiguous in the lexicographical
   ordering of all variable names known in the MIB.

   The type-specific naming of object instances is defined below for a
   number of classes of object types.  Instances of an object type to
   which none of the following naming conventions are applicable are
   named by OBJECT IDENTIFIERs of the form x.0, where x is the name of
   said object type in the MIB definition.

   For example, suppose one wanted to identify an instance of the
   variable sysDescr The object class for sysDescr is:

             iso org dod internet mgmt mib system sysDescr
              1   3   6     1      2    1    1       1

   Hence, the object type, x, would be 1.3.6.1.2.1.1.1 to which is
   appended an instance sub-identifier of 0.  That is, 1.3.6.1.2.1.1.1.0
   identifies the one and only instance of sysDescr.

3.2.6.3.1.  ifTable Object Type Names

   The name of a subnet interface, s, is the OBJECT IDENTIFIER value of
   the form i, where i has the value of that instance of the ifIndex
   object type associated with s.

   For each object type, t, for which the defined name, n, has a prefix
   of ifEntry, an instance, i, of t is named by an OBJECT IDENTIFIER of
   the form n.s, where s is the name of the subnet interface about which
   i represents information.

   For example, suppose one wanted to identify the instance of the
   variable ifType associated with interface 2.  Accordingly, ifType.2
   would identify the desired instance.

3.2.6.3.2.  atTable Object Type Names

   The name of an AT-cached network address, x, is an OBJECT IDENTIFIER
   of the form 1.a.b.c.d, where a.b.c.d is the value (in the familiar
   "dot" notation) of the atNetAddress object type associated with x.

   The name of an address translation equivalence e is an OBJECT
   IDENTIFIER value of the form s.w, such that s is the value of that
   instance of the atIndex object type associated with e and such that w
   is the name of the AT-cached network address associated with e.



Case, Fedor, Schoffstall, & Davin                              [Page 13]

RFC 1157                          SNMP                          May 1990


   For each object type, t, for which the defined name, n, has a prefix
   of atEntry, an instance, i, of t is named by an OBJECT IDENTIFIER of
   the form n.y, where y is the name of the address translation
   equivalence about which i represents information.

   For example, suppose one wanted to find the physical address of an
   entry in the address translation table (ARP cache) associated with an
   IP address of 89.1.1.42 and interface 3.  Accordingly,
   atPhysAddress.3.1.89.1.1.42 would identify the desired instance.

3.2.6.3.3.  ipAddrTable Object Type Names

   The name of an IP-addressable network element, x, is the OBJECT
   IDENTIFIER of the form a.b.c.d such that a.b.c.d is the value (in the
   familiar "dot" notation) of that instance of the ipAdEntAddr object
   type associated with x.

   For each object type, t, for which the defined name, n, has a prefix
   of ipAddrEntry, an instance, i, of t is named by an OBJECT IDENTIFIER
   of the form n.y, where y is the name of the IP-addressable network
   element about which i represents information.

   For example, suppose one wanted to find the network mask of an entry
   in the IP interface table associated with an IP address of 89.1.1.42.
   Accordingly, ipAdEntNetMask.89.1.1.42 would identify the desired
   instance.

3.2.6.3.4.  ipRoutingTable Object Type Names

   The name of an IP route, x, is the OBJECT IDENTIFIER of the form
   a.b.c.d such that a.b.c.d is the value (in the familiar "dot"
   notation) of that instance of the ipRouteDest object type associated
   with x.

   For each object type, t, for which the defined name, n, has a prefix
   of ipRoutingEntry, an instance, i, of t is named by an OBJECT
   IDENTIFIER of the form n.y, where y is the name of the IP route about
   which i represents information.

   For example, suppose one wanted to find the next hop of an entry in
   the IP routing table associated  with the destination of 89.1.1.42.
   Accordingly, ipRouteNextHop.89.1.1.42 would identify the desired
   instance.

3.2.6.3.5.  tcpConnTable Object Type Names

   The name of a TCP connection, x, is the OBJECT IDENTIFIER of the form
   a.b.c.d.e.f.g.h.i.j such that a.b.c.d is the value (in the familiar



Case, Fedor, Schoffstall, & Davin                              [Page 14]

RFC 1157                          SNMP                          May 1990


   "dot" notation) of that instance of the tcpConnLocalAddress object
   type associated with x and such that f.g.h.i is the value (in the
   familiar "dot" notation) of that instance of the tcpConnRemoteAddress
   object type associated with x and such that e is the value of that
   instance of the tcpConnLocalPort object type associated with x and
   such that j is the value of that instance of the tcpConnRemotePort
   object type associated with x.

   For each object type, t, for which the defined name, n, has a prefix
   of  tcpConnEntry, an instance, i, of t is named by an OBJECT
   IDENTIFIER of the form n.y, where y is the name of the TCP connection
   about which i represents information.

   For example, suppose one wanted to find the state of a TCP connection
   between the local address of 89.1.1.42 on TCP port 21 and the remote
   address of 10.0.0.51 on TCP port 2059.  Accordingly,
   tcpConnState.89.1.1.42.21.10.0.0.51.2059 would identify the desired
   instance.

3.2.6.3.6.  egpNeighTable Object Type Names

   The name of an EGP neighbor, x, is the OBJECT IDENTIFIER of the form
   a.b.c.d such that a.b.c.d is the value (in the familiar "dot"
   notation) of that instance of the egpNeighAddr object type associated
   with x.

   For each object type, t, for which the defined name, n, has a prefix
   of egpNeighEntry, an instance, i, of t is named by an OBJECT
   IDENTIFIER of the form n.y, where y is the name of the EGP neighbor
   about which i represents information.

   For example, suppose one wanted to find the neighbor state for the IP
   address of 89.1.1.42.  Accordingly, egpNeighState.89.1.1.42 would
   identify the desired instance.

















Case, Fedor, Schoffstall, & Davin                              [Page 15]

RFC 1157                          SNMP                          May 1990


4.  Protocol Specification

   The network management protocol is an application protocol by which
   the variables of an agent's MIB may be inspected or altered.

   Communication among protocol entities is accomplished by the exchange
   of messages, each of which is entirely and independently represented
   within a single UDP datagram using the basic encoding rules of ASN.1
   (as discussed in Section 3.2.2).  A message consists of a version
   identifier, an SNMP community name, and a protocol data unit (PDU).
   A protocol entity receives messages at UDP port 161 on the host with
   which it is associated for all messages except for those which report
   traps (i.e., all messages except those which contain the Trap-PDU).
   Messages which report traps should be received on UDP port 162 for
   further processing.  An implementation of this protocol need not
   accept messages whose length exceeds 484 octets.  However, it is
   recommended that implementations support larger datagrams whenever
   feasible.

   It is mandatory that all implementations of the SNMP support the five
   PDUs:  GetRequest-PDU, GetNextRequest-PDU, GetResponse-PDU,
   SetRequest-PDU, and Trap-PDU.

    RFC1157-SNMP DEFINITIONS ::= BEGIN

     IMPORTS
          ObjectName, ObjectSyntax, NetworkAddress, IpAddress, TimeTicks
                  FROM RFC1155-SMI;


     -- top-level message

             Message ::=
                     SEQUENCE {
                          version        -- version-1 for this RFC
                             INTEGER {
                                 version-1(0)
                             },

                         community      -- community name
                             OCTET STRING,

                         data           -- e.g., PDUs if trivial
                             ANY        -- authentication is being used
                     }






Case, Fedor, Schoffstall, & Davin                              [Page 16]

RFC 1157                          SNMP                          May 1990


     -- protocol data units

             PDUs ::=
                     CHOICE {
                         get-request
                             GetRequest-PDU,

                         get-next-request
                             GetNextRequest-PDU,

                         get-response
                             GetResponse-PDU,

                         set-request
                             SetRequest-PDU,

                         trap
                             Trap-PDU
                          }

     -- the individual PDUs and commonly used
     -- data types will be defined later

     END


4.1.  Elements of Procedure

   This section describes the actions of a protocol entity implementing
   the SNMP. Note, however, that it is not intended to constrain the
   internal architecture of any conformant implementation.

   In the text that follows, the term transport address is used.  In the
   case of the UDP, a transport address consists of an IP address along
   with a UDP port.  Other transport services may be used to support the
   SNMP.  In these cases, the definition of a transport address should
   be made accordingly.

   The top-level actions of a protocol entity which generates a message
   are as follows:

        (1)  It first constructs the appropriate PDU, e.g., the
             GetRequest-PDU, as an ASN.1 object.

        (2)  It then passes this ASN.1 object along with a community
             name its source transport address and the destination
             transport address, to the service which implements the
             desired authentication scheme.  This authentication



Case, Fedor, Schoffstall, & Davin                              [Page 17]

RFC 1157                          SNMP                          May 1990


             service returns another ASN.1 object.

        (3)  The protocol entity then constructs an ASN.1 Message
             object, using the community name and the resulting ASN.1
             object.

        (4)  This new ASN.1 object is then serialized, using the basic
             encoding rules of ASN.1, and then sent using a transport
             service to the peer protocol entity.

   Similarly, the top-level actions of a protocol entity which receives
   a message are as follows:

        (1)  It performs a rudimentary parse of the incoming datagram
             to build an ASN.1 object corresponding to an ASN.1
             Message object. If the parse fails, it discards the
             datagram and performs no further actions.

        (2)  It then verifies the version number of the SNMP message.
             If there is a mismatch, it discards the datagram and
             performs no further actions.

        (3)  The protocol entity then passes the community name and
             user data found in the ASN.1 Message object, along with
             the datagram's source and destination transport addresses
             to the service which implements the desired
             authentication scheme.  This entity returns another ASN.1
             object, or signals an authentication failure.  In the
             latter case, the protocol entity notes this failure,
             (possibly) generates a trap, and discards the datagram
             and performs no further actions.

        (4)  The protocol entity then performs a rudimentary parse on
             the ASN.1 object returned from the authentication service
             to build an ASN.1 object corresponding to an ASN.1 PDUs
             object.  If the parse fails, it discards the datagram and
             performs no further actions.  Otherwise, using the named
             SNMP community, the appropriate profile is selected, and
             the PDU is processed accordingly.  If, as a result of
             this processing, a message is returned then the source
             transport address that the response message is sent from
             shall be identical to the destination transport address
             that the original request message was sent to.








Case, Fedor, Schoffstall, & Davin                              [Page 18]

RFC 1157                          SNMP                          May 1990


4.1.1.  Common Constructs

   Before introducing the six PDU types of the protocol, it is
   appropriate to consider some of the ASN.1 constructs used frequently:

                  -- request/response information

                  RequestID ::=
                          INTEGER

                  ErrorStatus ::=
                          INTEGER {
                              noError(0),
                              tooBig(1),
                              noSuchName(2),
                              badValue(3),
                              readOnly(4)
                              genErr(5)
                          }

                  ErrorIndex ::=
                          INTEGER


                  -- variable bindings

                  VarBind ::=
                          SEQUENCE {
                              name
                                  ObjectName,

                              value
                                  ObjectSyntax
                          }

                  VarBindList ::=
                          SEQUENCE OF
                              VarBind


   RequestIDs are used to distinguish among outstanding requests.  By
   use of the RequestID, an SNMP application entity can correlate
   incoming responses with outstanding requests.  In cases where an
   unreliable datagram service is being used, the RequestID also
   provides a simple means of identifying messages duplicated by the
   network.

   A non-zero instance of ErrorStatus is used to indicate that an



Case, Fedor, Schoffstall, & Davin                              [Page 19]

RFC 1157                          SNMP                          May 1990


   exception occurred while processing a request.  In these cases,
   ErrorIndex may provide additional information by indicating which
   variable in a list caused the exception.

   The term variable refers to an instance of a managed object.  A
   variable binding, or VarBind, refers to the pairing of the name of a
   variable to the variable's value.  A VarBindList is a simple list of
   variable names and corresponding values.  Some PDUs are concerned
   only with the name of a variable and not its value (e.g., the
   GetRequest-PDU).  In this case, the value portion of the binding is
   ignored by the protocol entity.  However, the value portion must
   still have valid ASN.1 syntax and encoding.  It is recommended that
   the ASN.1 value NULL be used for the value portion of such bindings.

4.1.2.  The GetRequest-PDU

             The form of the GetRequest-PDU is:
                  GetRequest-PDU ::=
                      [0]
                          IMPLICIT SEQUENCE {
                              request-id
                                  RequestID,

                              error-status        -- always 0
                                  ErrorStatus,

                              error-index         -- always 0
                                  ErrorIndex,

                              variable-bindings
                                  VarBindList
                          }


   The GetRequest-PDU is generated by a protocol entity only at the
   request of its SNMP application entity.

   Upon receipt of the GetRequest-PDU, the receiving protocol entity
   responds according to any applicable rule in the list below:

        (1)  If, for any object named in the variable-bindings field,
             the object's name does not exactly match the name of some
             object available for get operations in the relevant MIB
             view, then the receiving entity sends to the originator
             of the received message the GetResponse-PDU of identical
             form, except that the value of the error-status field is
             noSuchName, and the value of the error-index field is the
             index of said object name component in the received



Case, Fedor, Schoffstall, & Davin                              [Page 20]

RFC 1157                          SNMP                          May 1990


             message.

        (2)  If, for any object named in the variable-bindings field,
             the object is an aggregate type (as defined in the SMI),
             then the receiving entity sends to the originator of the
             received message the GetResponse-PDU of identical form,
             except that the value of the error-status field is
             noSuchName, and the value of the error-index field is the
             index of said object name component in the received
             message.

        (3)  If the size of the GetResponse-PDU generated as described
             below would exceed a local limitation, then the receiving
             entity sends to the originator of the received message
             the GetResponse-PDU of identical form, except that the
             value of the error-status field is tooBig, and the value
             of the error-index field is zero.

        (4)  If, for any object named in the variable-bindings field,
             the value of the object cannot be retrieved for reasons
             not covered by any of the foregoing rules, then the
             receiving entity sends to the originator of the received
             message the GetResponse-PDU of identical form, except
             that the value of the error-status field is genErr and
             the value of the error-index field is the index of said
             object name component in the received message.

   If none of the foregoing rules apply, then the receiving protocol
   entity sends to the originator of the received message the
   GetResponse-PDU such that, for each object named in the variable-
   bindings field of the received message, the corresponding component
   of the GetResponse-PDU represents the name and value of that
   variable.  The value of the error- status field of the GetResponse-
   PDU is noError and the value of the error-index field is zero.  The
   value of the request-id field of the GetResponse-PDU is that of the
   received message.

4.1.3.  The GetNextRequest-PDU

   The form of the GetNextRequest-PDU is identical to that of the
   GetRequest-PDU except for the indication of the PDU type.  In the
   ASN.1 language:

                  GetNextRequest-PDU ::=
                      [1]
                          IMPLICIT SEQUENCE {
                              request-id
                                  RequestID,



Case, Fedor, Schoffstall, & Davin                              [Page 21]

RFC 1157                          SNMP                          May 1990


                              error-status        -- always 0
                                  ErrorStatus,

                              error-index         -- always 0
                                  ErrorIndex,

                              variable-bindings
                                  VarBindList
                          }


   The GetNextRequest-PDU is generated by a protocol entity only at the
   request of its SNMP application entity.

   Upon receipt of the GetNextRequest-PDU, the receiving protocol entity
   responds according to any applicable rule in the list below:

        (1)  If, for any object name in the variable-bindings field,
             that name does not lexicographically precede the name of
             some object available for get operations in the relevant
             MIB view, then the receiving entity sends to the
             originator of the received message the GetResponse-PDU of
             identical form, except that the value of the error-status
             field is noSuchName, and the value of the error-index
             field is the index of said object name component in the
             received message.

        (2)  If the size of the GetResponse-PDU generated as described
             below would exceed a local limitation, then the receiving
             entity sends to the originator of the received message
             the GetResponse-PDU of identical form, except that the
             value of the error-status field is tooBig, and the value
             of the error-index field is zero.

        (3)  If, for any object named in the variable-bindings field,
             the value of the lexicographical successor to the named
             object cannot be retrieved for reasons not covered by any
             of the foregoing rules, then the receiving entity sends
             to the originator of the received message the
             GetResponse-PDU of identical form, except that the value
             of the error-status field is genErr and the value of the
             error-index field is the index of said object name
             component in the received message.

   If none of the foregoing rules apply, then the receiving protocol
   entity sends to the originator of the received message the
   GetResponse-PDU such that, for each name in the variable-bindings
   field of the received message, the corresponding component of the



Case, Fedor, Schoffstall, & Davin                              [Page 22]

RFC 1157                          SNMP                          May 1990


   GetResponse-PDU represents the name and value of that object whose
   name is, in the lexicographical ordering of the names of all objects
   available for get operations in the relevant MIB view, together with
   the value of the name field of the given component, the immediate
   successor to that value.  The value of the error-status field of the
   GetResponse-PDU is noError and the value of the errorindex field is
   zero.  The value of the request-id field of the GetResponse-PDU is
   that of the received message.

4.1.3.1.  Example of Table Traversal

   One important use of the GetNextRequest-PDU is the traversal of
   conceptual tables of information within the MIB. The semantics of
   this type of SNMP message, together with the protocol-specific
   mechanisms for identifying individual instances of object types in
   the MIB, affords  access to related objects in the MIB as if they
   enjoyed a tabular organization.

   By the SNMP exchange sketched below, an SNMP application entity might
   extract the destination address and next hop gateway for each entry
   in the routing table of a particular network element. Suppose that
   this routing table has three entries:

         Destination                     NextHop         Metric

         10.0.0.99                       89.1.1.42       5
         9.1.2.3                         99.0.0.3        3
         10.0.0.51                       89.1.1.42       5


   The management station sends to the SNMP agent a GetNextRequest-PDU
   containing the indicated OBJECT IDENTIFIER values as the requested
   variable names:

   GetNextRequest ( ipRouteDest, ipRouteNextHop, ipRouteMetric1 )


   The SNMP agent responds with a GetResponse-PDU:

                 GetResponse (( ipRouteDest.9.1.2.3 =  "9.1.2.3" ),
                         ( ipRouteNextHop.9.1.2.3 = "99.0.0.3" ),
                         ( ipRouteMetric1.9.1.2.3 = 3 ))


   The management station continues with:

                 GetNextRequest ( ipRouteDest.9.1.2.3,
                         ipRouteNextHop.9.1.2.3,



Case, Fedor, Schoffstall, & Davin                              [Page 23]

RFC 1157                          SNMP                          May 1990


                         ipRouteMetric1.9.1.2.3 )


   The SNMP agent responds:

                 GetResponse (( ipRouteDest.10.0.0.51 = "10.0.0.51" ),
                         ( ipRouteNextHop.10.0.0.51 = "89.1.1.42" ),
                         ( ipRouteMetric1.10.0.0.51 = 5 ))


   The management station continues with:

                 GetNextRequest ( ipRouteDest.10.0.0.51,
                         ipRouteNextHop.10.0.0.51,
                         ipRouteMetric1.10.0.0.51 )


   The SNMP agent responds:

                 GetResponse (( ipRouteDest.10.0.0.99 = "10.0.0.99" ),
                         ( ipRouteNextHop.10.0.0.99 = "89.1.1.42" ),
                         ( ipRouteMetric1.10.0.0.99 = 5 ))


   The management station continues with:

                 GetNextRequest ( ipRouteDest.10.0.0.99,
                         ipRouteNextHop.10.0.0.99,
                         ipRouteMetric1.10.0.0.99 )


   As there are no further entries in the table, the SNMP agent returns
   those objects that are next in the lexicographical ordering of the
   known object names.  This response signals the end of the routing
   table to the management station.

4.1.4.  The GetResponse-PDU

   The form of the GetResponse-PDU is identical to that of the
   GetRequest-PDU except for the indication of the PDU type.  In the
   ASN.1 language:

                  GetResponse-PDU ::=
                      [2]
                          IMPLICIT SEQUENCE {
                              request-id
                                  RequestID,




Case, Fedor, Schoffstall, & Davin                              [Page 24]

RFC 1157                          SNMP                          May 1990


                              error-status
                                  ErrorStatus,

                              error-index
                                  ErrorIndex,

                              variable-bindings
                                  VarBindList
                          }


   The GetResponse-PDU is generated by a protocol entity only upon
   receipt of the GetRequest-PDU, GetNextRequest-PDU, or SetRequest-PDU,
   as described elsewhere in this document.

   Upon receipt of the GetResponse-PDU, the receiving protocol entity
   presents its contents to its SNMP application entity.

4.1.5.  The SetRequest-PDU

   The form of the SetRequest-PDU is identical to that of the
   GetRequest-PDU except for the indication of the PDU type.  In the
   ASN.1 language:

                  SetRequest-PDU ::=
                      [3]
                          IMPLICIT SEQUENCE {
                              request-id
                                  RequestID,

                              error-status        -- always 0
                                  ErrorStatus,

                              error-index         -- always 0
                                  ErrorIndex,

                              variable-bindings
                                  VarBindList
                          }


   The SetRequest-PDU is generated by a protocol entity only at the
   request of its SNMP application entity.

   Upon receipt of the SetRequest-PDU, the receiving entity responds
   according to any applicable rule in the list below:

        (1)  If, for any object named in the variable-bindings field,



Case, Fedor, Schoffstall, & Davin                              [Page 25]

RFC 1157                          SNMP                          May 1990


             the object is not available for set operations in the
             relevant MIB view, then the receiving entity sends to the
             originator of the received message the GetResponse-PDU of
             identical form, except that the value of the error-status
             field is noSuchName, and the value of the error-index
             field is the index of said object name component in the
             received message.

        (2)  If, for any object named in the variable-bindings field,
             the contents of the value field does not, according to
             the ASN.1 language, manifest a type, length, and value
             that is consistent with that required for the variable,
             then the receiving entity sends to the originator of the
             received message the GetResponse-PDU of identical form,
             except that the value of the error-status field is
             badValue, and the value of the error-index field is the
             index of said object name in the received message.

        (3)  If the size of the Get Response type message generated as
             described below would exceed a local limitation, then the
             receiving entity sends to the originator of the received
             message the GetResponse-PDU of identical form, except
             that the value of the error-status field is tooBig, and
             the value of the error-index field is zero.

        (4)  If, for any object named in the variable-bindings field,
             the value of the named object cannot be altered for
             reasons not covered by any of the foregoing rules, then
             the receiving entity sends to the originator of the
             received message the GetResponse-PDU of identical form,
             except that the value of the error-status field is genErr
             and the value of the error-index field is the index of
             said object name component in the received message.

   If none of the foregoing rules apply, then for each object named in
   the variable-bindings field of the received message, the
   corresponding value is assigned to the variable.  Each variable
   assignment specified by the SetRequest-PDU should be effected as if
   simultaneously set with respect to all other assignments specified in
   the same message.

   The receiving entity then sends to the originator of the received
   message the GetResponse-PDU of identical form except that the value
   of the error-status field of the generated message is noError and the
   value of the error-index field is zero.






Case, Fedor, Schoffstall, & Davin                              [Page 26]

RFC 1157                          SNMP                          May 1990


4.1.6.  The Trap-PDU

   The form of the Trap-PDU is:

     Trap-PDU ::=
         [4]

              IMPLICIT SEQUENCE {
                 enterprise          -- type of object generating
                                     -- trap, see sysObjectID in [5]
                     OBJECT IDENTIFIER,

                 agent-addr          -- address of object generating
                     NetworkAddress, -- trap

                 generic-trap        -- generic trap type
                     INTEGER {
                         coldStart(0),
                         warmStart(1),
                         linkDown(2),
                         linkUp(3),
                         authenticationFailure(4),
                         egpNeighborLoss(5),
                         enterpriseSpecific(6)
                     },

                 specific-trap     -- specific code, present even
                     INTEGER,      -- if generic-trap is not
                                   -- enterpriseSpecific

                 time-stamp        -- time elapsed between the last
                   TimeTicks,      -- (re)initialization of the network
                                   -- entity and the generation of the
                                      trap

                 variable-bindings   -- "interesting" information
                      VarBindList
             }


   The Trap-PDU is generated by a protocol entity only at the request of
   the SNMP application entity.  The means by which an SNMP application
   entity selects the destination addresses of the SNMP application
   entities is implementation-specific.

   Upon receipt of the Trap-PDU, the receiving protocol entity presents
   its contents to its SNMP application entity.




Case, Fedor, Schoffstall, & Davin                              [Page 27]

RFC 1157                          SNMP                          May 1990


   The significance of the variable-bindings component of the Trap-PDU
   is implementation-specific.

   Interpretations of the value of the generic-trap field are:

4.1.6.1.  The coldStart Trap

   A coldStart(0) trap signifies that the sending protocol entity is
   reinitializing itself such that the agent's configuration or the
   protocol entity implementation may be altered.

4.1.6.2.  The warmStart Trap

   A warmStart(1) trap signifies that the sending protocol entity is
   reinitializing itself such that neither the agent configuration nor
   the protocol entity implementation is altered.

4.1.6.3.  The linkDown Trap

   A linkDown(2) trap signifies that the sending protocol entity
   recognizes a failure in one of the communication links represented in
   the agent's configuration.

   The Trap-PDU of type linkDown contains as the first element of its
   variable-bindings, the name and value of the ifIndex instance for the
   affected interface.

4.1.6.4.  The linkUp Trap

   A linkUp(3) trap signifies that the sending protocol entity
   recognizes that one of the communication links represented in the
   agent's configuration has come up.

   The Trap-PDU of type linkUp contains as the first element of its
   variable-bindings, the name and value of the ifIndex instance for the
   affected interface.

4.1.6.5.  The authenticationFailure Trap

   An authenticationFailure(4) trap signifies that the sending protocol
   entity is the addressee of a protocol message that is not properly
   authenticated.  While implementations of the SNMP must be capable of
   generating this trap, they must also be capable of suppressing the
   emission of such traps via an implementation-specific mechanism.

4.1.6.6.  The egpNeighborLoss Trap

   An egpNeighborLoss(5) trap signifies that an EGP neighbor for whom



Case, Fedor, Schoffstall, & Davin                              [Page 28]

RFC 1157                          SNMP                          May 1990


   the sending protocol entity was an EGP peer has been marked down and
   the peer relationship no longer obtains.

   The Trap-PDU of type egpNeighborLoss contains as the first element of
   its variable-bindings, the name and value of the egpNeighAddr
   instance for the affected neighbor.

4.1.6.7.  The enterpriseSpecific Trap

   A enterpriseSpecific(6) trap signifies that the sending protocol
   entity recognizes that some enterprise-specific event has occurred.
   The specific-trap field identifies the particular trap which
   occurred.






































Case, Fedor, Schoffstall, & Davin                              [Page 29]

RFC 1157                          SNMP                          May 1990


5.  Definitions

     RFC1157-SNMP DEFINITIONS ::= BEGIN

      IMPORTS
          ObjectName, ObjectSyntax, NetworkAddress, IpAddress, TimeTicks
              FROM RFC1155-SMI;


          -- top-level message

          Message ::=
                  SEQUENCE {
                      version          -- version-1 for this RFC
                          INTEGER {
                              version-1(0)
                          },

                      community        -- community name
                          OCTET STRING,

                      data             -- e.g., PDUs if trivial
                          ANY          -- authentication is being used
                  }


          -- protocol data units

          PDUs ::=
                  CHOICE {
                              get-request
                                  GetRequest-PDU,

                              get-next-request
                                  GetNextRequest-PDU,

                              get-response
                                  GetResponse-PDU,

                              set-request
                                  SetRequest-PDU,

                              trap
                                  Trap-PDU
                          }






Case, Fedor, Schoffstall, & Davin                              [Page 30]

RFC 1157                          SNMP                          May 1990


          -- PDUs

          GetRequest-PDU ::=
              [0]
                  IMPLICIT PDU

          GetNextRequest-PDU ::=
              [1]
                  IMPLICIT PDU

          GetResponse-PDU ::=
              [2]
                  IMPLICIT PDU

          SetRequest-PDU ::=
              [3]
                  IMPLICIT PDU

          PDU ::=
                  SEQUENCE {
                     request-id
                          INTEGER,

                      error-status      -- sometimes ignored
                          INTEGER {
                              noError(0),
                              tooBig(1),
                              noSuchName(2),
                              badValue(3),
                              readOnly(4),
                              genErr(5)
                          },

                      error-index       -- sometimes ignored
                         INTEGER,

                      variable-bindings -- values are sometimes ignored
                          VarBindList
                  }

          Trap-PDU ::=
              [4]
                 IMPLICIT SEQUENCE {
                      enterprise        -- type of object generating
                                        -- trap, see sysObjectID in [5]


                          OBJECT IDENTIFIER,



Case, Fedor, Schoffstall, & Davin                              [Page 31]

RFC 1157                          SNMP                          May 1990


                      agent-addr        -- address of object generating
                          NetworkAddress, -- trap

                      generic-trap      -- generic trap type
                          INTEGER {
                              coldStart(0),
                              warmStart(1),
                              linkDown(2),
                              linkUp(3),
                              authenticationFailure(4),
                              egpNeighborLoss(5),
                              enterpriseSpecific(6)
                          },

                      specific-trap  -- specific code, present even
                          INTEGER,   -- if generic-trap is not
                                     -- enterpriseSpecific

                      time-stamp     -- time elapsed between the last
                          TimeTicks, -- (re)initialization of the
                                        network
                                     -- entity and the generation of the
                                        trap

                       variable-bindings -- "interesting" information
                          VarBindList
                  }


          -- variable bindings

          VarBind ::=
                  SEQUENCE {
                      name
                          ObjectName,

                      value
                          ObjectSyntax
                  }

         VarBindList ::=
                  SEQUENCE OF
                     VarBind

         END






Case, Fedor, Schoffstall, & Davin                              [Page 32]

RFC 1157                          SNMP                          May 1990


6.  Acknowledgements

   This memo was influenced by the IETF SNMP Extensions working
   group:

             Karl Auerbach, Epilogue Technology
             K. Ramesh Babu, Excelan
             Amatzia Ben-Artzi, 3Com/Bridge
             Lawrence Besaw, Hewlett-Packard
             Jeffrey D. Case, University of Tennessee at Knoxville
             Anthony Chung, Sytek
             James Davidson, The Wollongong Group
             James R. Davin, MIT Laboratory for Computer Science
             Mark S. Fedor, NYSERNet
             Phill Gross, The MITRE Corporation
             Satish Joshi, ACC
             Dan Lynch, Advanced Computing Environments
             Keith McCloghrie, The Wollongong Group
             Marshall T. Rose, The Wollongong Group (chair)
             Greg Satz, cisco
             Martin Lee Schoffstall, Rensselaer Polytechnic Institute
             Wengyik Yeong, NYSERNet





























Case, Fedor, Schoffstall, & Davin                              [Page 33]

RFC 1157                          SNMP                          May 1990


7.  References

   [1] Cerf, V., "IAB Recommendations for the Development of
       Internet Network Management Standards", RFC 1052, IAB,
       April 1988.

   [2] Rose, M., and K. McCloghrie, "Structure and Identification
       of Management Information for TCP/IP-based internets",
       RFC 1065, TWG, August 1988.

   [3] McCloghrie, K., and M. Rose, "Management Information Base
       for Network Management of TCP/IP-based internets",
       RFC 1066, TWG, August 1988.

   [4] Cerf, V., "Report of the Second Ad Hoc Network Management
       Review Group", RFC 1109, IAB, August 1989.

   [5] Rose, M., and K. McCloghrie, "Structure and Identification
       of Management Information for TCP/IP-based Internets",
       RFC 1155, Performance Systems International and Hughes LAN
       Systems, May 1990.

   [6] McCloghrie, K., and M. Rose, "Management Information Base
       for Network Management of TCP/IP-based Internets",
       RFC 1156, Hughes LAN Systems and Performance Systems
       International, May 1990.

   [7] Case, J., M. Fedor, M. Schoffstall, and J. Davin,
       "A Simple Network Management Protocol", Internet
       Engineering Task Force working note, Network Information
       Center, SRI International, Menlo Park, California,
       March 1988.

   [8] Davin, J., J. Case, M. Fedor, and M. Schoffstall,
       "A Simple Gateway Monitoring Protocol", RFC 1028,
       Proteon, University of Tennessee at Knoxville,
       Cornell University, and Rensselaer Polytechnic
       Institute, November 1987.

   [9] Information processing systems - Open Systems
       Interconnection, "Specification of Abstract Syntax
       Notation One (ASN.1)", International Organization for
       Standardization, International Standard 8824,
       December 1987.

  [10] Information processing systems - Open Systems
       Interconnection, "Specification of Basic Encoding Rules
       for Abstract Notation One (ASN.1)", International



Case, Fedor, Schoffstall, & Davin                              [Page 34]

RFC 1157                          SNMP                          May 1990


       Organization for Standardization, International Standard
       8825, December 1987.

  [11] Postel, J., "User Datagram Protocol", RFC 768,
       USC/Information Sciences Institute, November 1980.

Security Considerations

   Security issues are not discussed in this memo.

Authors' Addresses

   Jeffrey D. Case
   SNMP Research
   P.O. Box 8593
   Knoxville, TN 37996-4800

   Phone:  (615) 573-1434

   Email:  case@CS.UTK.EDU


   Mark Fedor
   Performance Systems International
   Rensselaer Technology Park
   125 Jordan Road
   Troy, NY 12180

   Phone:  (518) 283-8860

   Email:  fedor@patton.NYSER.NET


   Martin Lee Schoffstall
   Performance Systems International
   Rensselaer Technology Park
   165 Jordan Road
   Troy, NY 12180

   Phone:  (518) 283-8860

   Email:  schoff@NISC.NYSER.NET









Case, Fedor, Schoffstall, & Davin                              [Page 35]

RFC 1157                          SNMP                          May 1990


   James R. Davin
   MIT Laboratory for Computer Science, NE43-507
   545 Technology Square
   Cambridge, MA 02139

   Phone:  (617) 253-6020

   EMail:  jrd@ptt.lcs.mit.edu











































Case, Fedor, Schoffstall, & Davin                              [Page 36]
[H[2J
termsaver.rfc: Connecting to http://tools.ietf.org/rfc/rfc2326.txt ... (this could take a while)






Network Working Group                                     H. Schulzrinne
Request for Comments: 2326                                   Columbia U.
Category: Standards Track                                         A. Rao
                                                                Netscape
                                                             R. Lanphier
                                                            RealNetworks
                                                              April 1998

                  Real Time Streaming Protocol (RTSP)

Status of this Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the "Internet
   Official Protocol Standards" (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (1998).  All Rights Reserved.

Abstract

   The Real Time Streaming Protocol, or RTSP, is an application-level
   protocol for control over the delivery of data with real-time
   properties. RTSP provides an extensible framework to enable
   controlled, on-demand delivery of real-time data, such as audio and
   video. Sources of data can include both live data feeds and stored
   clips. This protocol is intended to control multiple data delivery
   sessions, provide a means for choosing delivery channels such as UDP,
   multicast UDP and TCP, and provide a means for choosing delivery
   mechanisms based upon RTP (RFC 1889).

Table of Contents

   * 1 Introduction .................................................  5
        + 1.1 Purpose ...............................................  5
        + 1.2 Requirements ..........................................  6
        + 1.3 Terminology ...........................................  6
        + 1.4 Protocol Properties ...................................  9
        + 1.5 Extending RTSP ........................................ 11
        + 1.6 Overall Operation ..................................... 11
        + 1.7 RTSP States ........................................... 12
        + 1.8 Relationship with Other Protocols ..................... 13
   * 2 Notational Conventions ....................................... 14
   * 3 Protocol Parameters .......................................... 14
        + 3.1 RTSP Version .......................................... 14



Schulzrinne, et. al.        Standards Track                     [Page 1]

RFC 2326              Real Time Streaming Protocol            April 1998


        + 3.2 RTSP URL .............................................. 14
        + 3.3 Conference Identifiers ................................ 16
        + 3.4 Session Identifiers ................................... 16
        + 3.5 SMPTE Relative Timestamps ............................. 16
        + 3.6 Normal Play Time ...................................... 17
        + 3.7 Absolute Time ......................................... 18
        + 3.8 Option Tags ........................................... 18
             o 3.8.1 Registering New Option Tags with IANA .......... 18
   * 4 RTSP Message ................................................. 19
        + 4.1 Message Types ......................................... 19
        + 4.2 Message Headers ....................................... 19
        + 4.3 Message Body .......................................... 19
        + 4.4 Message Length ........................................ 20
   * 5 General Header Fields ........................................ 20
   * 6 Request ...................................................... 20
        + 6.1 Request Line .......................................... 21
        + 6.2 Request Header Fields ................................. 21
   * 7 Response ..................................................... 22
        + 7.1 Status-Line ........................................... 22
             o 7.1.1 Status Code and Reason Phrase .................. 22
             o 7.1.2 Response Header Fields ......................... 26
   * 8 Entity ....................................................... 27
        + 8.1 Entity Header Fields .................................. 27
        + 8.2 Entity Body ........................................... 28
   * 9 Connections .................................................. 28
        + 9.1 Pipelining ............................................ 28
        + 9.2 Reliability and Acknowledgements ...................... 28
   * 10 Method Definitions .......................................... 29
        + 10.1 OPTIONS .............................................. 30
        + 10.2 DESCRIBE ............................................. 31
        + 10.3 ANNOUNCE ............................................. 32
        + 10.4 SETUP ................................................ 33
        + 10.5 PLAY ................................................. 34
        + 10.6 PAUSE ................................................ 36
        + 10.7 TEARDOWN ............................................. 37
        + 10.8 GET_PARAMETER ........................................ 37
        + 10.9 SET_PARAMETER ........................................ 38
        + 10.10 REDIRECT ............................................ 39
        + 10.11 RECORD .............................................. 39
        + 10.12 Embedded (Interleaved) Binary Data .................. 40
   * 11 Status Code Definitions ..................................... 41
        + 11.1 Success 2xx .......................................... 41
             o 11.1.1 250 Low on Storage Space ...................... 41
        + 11.2 Redirection 3xx ...................................... 41
        + 11.3 Client Error 4xx ..................................... 42
             o 11.3.1 405 Method Not Allowed ........................ 42
             o 11.3.2 451 Parameter Not Understood .................. 42
             o 11.3.3 452 Conference Not Found ...................... 42



Schulzrinne, et. al.        Standards Track                     [Page 2]

RFC 2326              Real Time Streaming Protocol            April 1998


             o 11.3.4 453 Not Enough Bandwidth ...................... 42
             o 11.3.5 454 Session Not Found ......................... 42
             o 11.3.6 455 Method Not Valid in This State ............ 42
             o 11.3.7 456 Header Field Not Valid for Resource ....... 42
             o 11.3.8 457 Invalid Range ............................. 43
             o 11.3.9 458 Parameter Is Read-Only .................... 43
             o 11.3.10 459 Aggregate Operation Not Allowed .......... 43
             o 11.3.11 460 Only Aggregate Operation Allowed ......... 43
             o 11.3.12 461 Unsupported Transport .................... 43
             o 11.3.13 462 Destination Unreachable .................. 43
             o 11.3.14 551 Option not supported ..................... 43
   * 12 Header Field Definitions .................................... 44
        + 12.1 Accept ............................................... 46
        + 12.2 Accept-Encoding ...................................... 46
        + 12.3 Accept-Language ...................................... 46
        + 12.4 Allow ................................................ 46
        + 12.5 Authorization ........................................ 46
        + 12.6 Bandwidth ............................................ 46
        + 12.7 Blocksize ............................................ 47
        + 12.8 Cache-Control ........................................ 47
        + 12.9 Conference ........................................... 49
        + 12.10 Connection .......................................... 49
        + 12.11 Content-Base ........................................ 49
        + 12.12 Content-Encoding .................................... 49
        + 12.13 Content-Language .................................... 50
        + 12.14 Content-Length ...................................... 50
        + 12.15 Content-Location .................................... 50
        + 12.16 Content-Type ........................................ 50
        + 12.17 CSeq ................................................ 50
        + 12.18 Date ................................................ 50
        + 12.19 Expires ............................................. 50
        + 12.20 From ................................................ 51
        + 12.21 Host ................................................ 51
        + 12.22 If-Match ............................................ 51
        + 12.23 If-Modified-Since ................................... 52
        + 12.24 Last-Modified........................................ 52
        + 12.25 Location ............................................ 52
        + 12.26 Proxy-Authenticate .................................. 52
        + 12.27 Proxy-Require ....................................... 52
        + 12.28 Public .............................................. 53
        + 12.29 Range ............................................... 53
        + 12.30 Referer ............................................. 54
        + 12.31 Retry-After ......................................... 54
        + 12.32 Require ............................................. 54
        + 12.33 RTP-Info ............................................ 55
        + 12.34 Scale ............................................... 56
        + 12.35 Speed ............................................... 57
        + 12.36 Server .............................................. 57



Schulzrinne, et. al.        Standards Track                     [Page 3]

RFC 2326              Real Time Streaming Protocol            April 1998


        + 12.37 Session ............................................. 57
        + 12.38 Timestamp ........................................... 58
        + 12.39 Transport ........................................... 58
        + 12.40 Unsupported ......................................... 62
        + 12.41 User-Agent .......................................... 62
        + 12.42 Vary ................................................ 62
        + 12.43 Via ................................................. 62
        + 12.44 WWW-Authenticate .................................... 62
   * 13 Caching ..................................................... 62
   * 14 Examples .................................................... 63
        + 14.1 Media on Demand (Unicast) ............................ 63
        + 14.2 Streaming of a Container file ........................ 65
        + 14.3 Single Stream Container Files ........................ 67
        + 14.4 Live Media Presentation Using Multicast .............. 69
        + 14.5 Playing media into an existing session ............... 70
        + 14.6 Recording ............................................ 71
   * 15 Syntax ...................................................... 72
        + 15.1 Base Syntax .......................................... 72
   * 16 Security Considerations ..................................... 73
   * A RTSP Protocol State Machines ................................. 76
        + A.1 Client State Machine .................................. 76
        + A.2 Server State Machine .................................. 77
   * B Interaction with RTP ......................................... 79
   * C Use of SDP for RTSP Session Descriptions ..................... 80
        + C.1 Definitions ........................................... 80
             o C.1.1 Control URL .................................... 80
             o C.1.2 Media streams .................................. 81
             o C.1.3 Payload type(s) ................................ 81
             o C.1.4 Format-specific parameters ..................... 81
             o C.1.5 Range of presentation .......................... 82
             o C.1.6 Time of availability ........................... 82
             o C.1.7 Connection Information ......................... 82
             o C.1.8 Entity Tag ..................................... 82
        + C.2 Aggregate Control Not Available ....................... 83
        + C.3 Aggregate Control Available ........................... 83
   * D Minimal RTSP implementation .................................. 85
        + D.1 Client ................................................ 85
             o D.1.1 Basic Playback ................................. 86
             o D.1.2 Authentication-enabled ......................... 86
        + D.2 Server ................................................ 86
             o D.2.1 Basic Playback ................................. 87
             o D.2.2 Authentication-enabled ......................... 87
   * E Authors' Addresses ........................................... 88
   * F Acknowledgements ............................................. 89
   * References ..................................................... 90
   * Full Copyright Statement ....................................... 92





Schulzrinne, et. al.        Standards Track                     [Page 4]

RFC 2326              Real Time Streaming Protocol            April 1998


1 Introduction

1.1 Purpose

   The Real-Time Streaming Protocol (RTSP) establishes and controls
   either a single or several time-synchronized streams of continuous
   media such as audio and video. It does not typically deliver the
   continuous streams itself, although interleaving of the continuous
   media stream with the control stream is possible (see Section 10.12).
   In other words, RTSP acts as a "network remote control" for
   multimedia servers.

   The set of streams to be controlled is defined by a presentation
   description. This memorandum does not define a format for a
   presentation description.

   There is no notion of an RTSP connection; instead, a server maintains
   a session labeled by an identifier. An RTSP session is in no way tied
   to a transport-level connection such as a TCP connection. During an
   RTSP session, an RTSP client may open and close many reliable
   transport connections to the server to issue RTSP requests.
   Alternatively, it may use a connectionless transport protocol such as
   UDP.

   The streams controlled by RTSP may use RTP [1], but the operation of
   RTSP does not depend on the transport mechanism used to carry
   continuous media.  The protocol is intentionally similar in syntax
   and operation to HTTP/1.1 [2] so that extension mechanisms to HTTP
   can in most cases also be added to RTSP. However, RTSP differs in a
   number of important aspects from HTTP:

     * RTSP introduces a number of new methods and has a different
       protocol identifier.
     * An RTSP server needs to maintain state by default in almost all
       cases, as opposed to the stateless nature of HTTP.
     * Both an RTSP server and client can issue requests.
     * Data is carried out-of-band by a different protocol. (There is an
       exception to this.)
     * RTSP is defined to use ISO 10646 (UTF-8) rather than ISO 8859-1,
       consistent with current HTML internationalization efforts [3].
     * The Request-URI always contains the absolute URI. Because of
       backward compatibility with a historical blunder, HTTP/1.1 [2]
       carries only the absolute path in the request and puts the host
       name in a separate header field.

     This makes "virtual hosting" easier, where a single host with one
     IP address hosts several document trees.




Schulzrinne, et. al.        Standards Track                     [Page 5]

RFC 2326              Real Time Streaming Protocol            April 1998


   The protocol supports the following operations:

   Retrieval of media from media server:
          The client can request a presentation description via HTTP or
          some other method. If the presentation is being multicast, the
          presentation description contains the multicast addresses and
          ports to be used for the continuous media. If the presentation
          is to be sent only to the client via unicast, the client
          provides the destination for security reasons.

   Invitation of a media server to a conference:
          A media server can be "invited" to join an existing
          conference, either to play back media into the presentation or
          to record all or a subset of the media in a presentation. This
          mode is useful for distributed teaching applications. Several
          parties in the conference may take turns "pushing the remote
          control buttons."

   Addition of media to an existing presentation:
          Particularly for live presentations, it is useful if the
          server can tell the client about additional media becoming
          available.

   RTSP requests may be handled by proxies, tunnels and caches as in
   HTTP/1.1 [2].

1.2 Requirements

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [4].

1.3 Terminology

   Some of the terminology has been adopted from HTTP/1.1 [2]. Terms not
   listed here are defined as in HTTP/1.1.

   Aggregate control:
          The control of the multiple streams using a single timeline by
          the server. For audio/video feeds, this means that the client
          may issue a single play or pause message to control both the
          audio and video feeds.

   Conference:
          a multiparty, multimedia presentation, where "multi" implies
          greater than or equal to one.





Schulzrinne, et. al.        Standards Track                     [Page 6]

RFC 2326              Real Time Streaming Protocol            April 1998


   Client:
          The client requests continuous media data from the media
          server.

   Connection:
          A transport layer virtual circuit established between two
          programs for the purpose of communication.

   Container file:
          A file which may contain multiple media streams which often
          comprise a presentation when played together. RTSP servers may
          offer aggregate control on these files, though the concept of
          a container file is not embedded in the protocol.

   Continuous media:
          Data where there is a timing relationship between source and
          sink; that is, the sink must reproduce the timing relationship
          that existed at the source. The most common examples of
          continuous media are audio and motion video. Continuous media
          can be real-time (interactive), where there is a "tight"
          timing relationship between source and sink, or streaming
          (playback), where the relationship is less strict.

   Entity:
          The information transferred as the payload of a request or
          response. An entity consists of metainformation in the form of
          entity-header fields and content in the form of an entity-
          body, as described in Section 8.

   Media initialization:
          Datatype/codec specific initialization. This includes such
          things as clockrates, color tables, etc. Any transport-
          independent information which is required by a client for
          playback of a media stream occurs in the media initialization
          phase of stream setup.

   Media parameter:
          Parameter specific to a media type that may be changed before
          or during stream playback.

   Media server:
          The server providing playback or recording services for one or
          more media streams. Different media streams within a
          presentation may originate from different media servers. A
          media server may reside on the same or a different host as the
          web server the presentation is invoked from.





Schulzrinne, et. al.        Standards Track                     [Page 7]

RFC 2326              Real Time Streaming Protocol            April 1998


   Media server indirection:
          Redirection of a media client to a different media server.

   (Media) stream:
          A single media instance, e.g., an audio stream or a video
          stream as well as a single whiteboard or shared application
          group. When using RTP, a stream consists of all RTP and RTCP
          packets created by a source within an RTP session. This is
          equivalent to the definition of a DSM-CC stream([5]).

   Message:
          The basic unit of RTSP communication, consisting of a
          structured sequence of octets matching the syntax defined in
          Section 15 and transmitted via a connection or a
          connectionless protocol.

   Participant:
          Member of a conference. A participant may be a machine, e.g.,
          a media record or playback server.

   Presentation:
          A set of one or more streams presented to the client as a
          complete media feed, using a presentation description as
          defined below. In most cases in the RTSP context, this implies
          aggregate control of those streams, but does not have to.

   Presentation description:
          A presentation description contains information about one or
          more media streams within a presentation, such as the set of
          encodings, network addresses and information about the
          content.  Other IETF protocols such as SDP (RFC 2327 [6]) use
          the term "session" for a live presentation. The presentation
          description may take several different formats, including but
          not limited to the session description format SDP.

   Response:
          An RTSP response. If an HTTP response is meant, that is
          indicated explicitly.

   Request:
          An RTSP request. If an HTTP request is meant, that is
          indicated explicitly.

   RTSP session:
          A complete RTSP "transaction", e.g., the viewing of a movie.
          A session typically consists of a client setting up a
          transport mechanism for the continuous media stream (SETUP),
          starting the stream with PLAY or RECORD, and closing the



Schulzrinne, et. al.        Standards Track                     [Page 8]

RFC 2326              Real Time Streaming Protocol            April 1998


          stream with TEARDOWN.

   Transport initialization:
          The negotiation of transport information (e.g., port numbers,
          transport protocols) between the client and the server.

1.4 Protocol Properties

   RTSP has the following properties:

   Extendable:
          New methods and parameters can be easily added to RTSP.

   Easy to parse:
          RTSP can be parsed by standard HTTP or MIME parsers.

   Secure:
          RTSP re-uses web security mechanisms. All HTTP authentication
          mechanisms such as basic (RFC 2068 [2, Section 11.1]) and
          digest authentication (RFC 2069 [8]) are directly applicable.
          One may also reuse transport or network layer security
          mechanisms.

   Transport-independent:
          RTSP may use either an unreliable datagram protocol (UDP) (RFC
          768 [9]), a reliable datagram protocol (RDP, RFC 1151, not
          widely used [10]) or a reliable stream protocol such as TCP
          (RFC 793 [11]) as it implements application-level reliability.

   Multi-server capable:
          Each media stream within a presentation can reside on a
          different server. The client automatically establishes several
          concurrent control sessions with the different media servers.
          Media synchronization is performed at the transport level.

   Control of recording devices:
          The protocol can control both recording and playback devices,
          as well as devices that can alternate between the two modes
          ("VCR").

   Separation of stream control and conference initiation:
          Stream control is divorced from inviting a media server to a
          conference. The only requirement is that the conference
          initiation protocol either provides or can be used to create a
          unique conference identifier. In particular, SIP [12] or H.323
          [13] may be used to invite a server to a conference.





Schulzrinne, et. al.        Standards Track                     [Page 9]

RFC 2326              Real Time Streaming Protocol            April 1998


   Suitable for professional applications:
          RTSP supports frame-level accuracy through SMPTE time stamps
          to allow remote digital editing.

   Presentation description neutral:
          The protocol does not impose a particular presentation
          description or metafile format and can convey the type of
          format to be used. However, the presentation description must
          contain at least one RTSP URI.

   Proxy and firewall friendly:
          The protocol should be readily handled by both application and
          transport-layer (SOCKS [14]) firewalls. A firewall may need to
          understand the SETUP method to open a "hole" for the UDP media
          stream.

   HTTP-friendly:
          Where sensible, RTSP reuses HTTP concepts, so that the
          existing infrastructure can be reused. This infrastructure
          includes PICS (Platform for Internet Content Selection
          [15,16]) for associating labels with content. However, RTSP
          does not just add methods to HTTP since the controlling
          continuous media requires server state in most cases.

   Appropriate server control:
          If a client can start a stream, it must be able to stop a
          stream. Servers should not start streaming to clients in such
          a way that clients cannot stop the stream.

   Transport negotiation:
          The client can negotiate the transport method prior to
          actually needing to process a continuous media stream.

   Capability negotiation:
          If basic features are disabled, there must be some clean
          mechanism for the client to determine which methods are not
          going to be implemented. This allows clients to present the
          appropriate user interface. For example, if seeking is not
          allowed, the user interface must be able to disallow moving a
          sliding position indicator.

     An earlier requirement in RTSP was multi-client capability.
     However, it was determined that a better approach was to make sure
     that the protocol is easily extensible to the multi-client
     scenario. Stream identifiers can be used by several control
     streams, so that "passing the remote" would be possible. The
     protocol would not address how several clients negotiate access;
     this is left to either a "social protocol" or some other floor



Schulzrinne, et. al.        Standards Track                    [Page 10]

RFC 2326              Real Time Streaming Protocol            April 1998


     control mechanism.

1.5 Extending RTSP

   Since not all media servers have the same functionality, media
   servers by necessity will support different sets of requests. For
   example:

     * A server may only be capable of playback thus has no need to
       support the RECORD request.
     * A server may not be capable of seeking (absolute positioning) if
       it is to support live events only.
     * Some servers may not support setting stream parameters and thus
       not support GET_PARAMETER and SET_PARAMETER.

   A server SHOULD implement all header fields described in Section 12.

   It is up to the creators of presentation descriptions not to ask the
   impossible of a server. This situation is similar in HTTP/1.1 [2],
   where the methods described in [H19.6] are not likely to be supported
   across all servers.

   RTSP can be extended in three ways, listed here in order of the
   magnitude of changes supported:

     * Existing methods can be extended with new parameters, as long as
       these parameters can be safely ignored by the recipient. (This is
       equivalent to adding new parameters to an HTML tag.) If the
       client needs negative acknowledgement when a method extension is
       not supported, a tag corresponding to the extension may be added
       in the Require: field (see Section 12.32).
     * New methods can be added. If the recipient of the message does
       not understand the request, it responds with error code 501 (Not
       implemented) and the sender should not attempt to use this method
       again. A client may also use the OPTIONS method to inquire about
       methods supported by the server. The server SHOULD list the
       methods it supports using the Public response header.
     * A new version of the protocol can be defined, allowing almost all
       aspects (except the position of the protocol version number) to
       change.

1.6 Overall Operation

   Each presentation and media stream may be identified by an RTSP URL.
   The overall presentation and the properties of the media the
   presentation is made up of are defined by a presentation description
   file, the format of which is outside the scope of this specification.
   The presentation description file may be obtained by the client using



Schulzrinne, et. al.        Standards Track                    [Page 11]

RFC 2326              Real Time Streaming Protocol            April 1998


   HTTP or other means such as email and may not necessarily be stored
   on the media server.

   For the purposes of this specification, a presentation description is
   assumed to describe one or more presentations, each of which
   maintains a common time axis. For simplicity of exposition and
   without loss of generality, it is assumed that the presentation
   description contains exactly one such presentation. A presentation
   may contain several media streams.

   The presentation description file contains a description of the media
   streams making up the presentation, including their encodings,
   language, and other parameters that enable the client to choose the
   most appropriate combination of media. In this presentation
   description, each media stream that is individually controllable by
   RTSP is identified by an RTSP URL, which points to the media server
   handling that particular media stream and names the stream stored on
   that server. Several media streams can be located on different
   servers; for example, audio and video streams can be split across
   servers for load sharing. The description also enumerates which
   transport methods the server is capable of.

   Besides the media parameters, the network destination address and
   port need to be determined. Several modes of operation can be
   distinguished:

   Unicast:
          The media is transmitted to the source of the RTSP request,
          with the port number chosen by the client. Alternatively, the
          media is transmitted on the same reliable stream as RTSP.

   Multicast, server chooses address:
          The media server picks the multicast address and port. This is
          the typical case for a live or near-media-on-demand
          transmission.

   Multicast, client chooses address:
          If the server is to participate in an existing multicast
          conference, the multicast address, port and encryption key are
          given by the conference description, established by means
          outside the scope of this specification.

1.7 RTSP States

   RTSP controls a stream which may be sent via a separate protocol,
   independent of the control channel. For example, RTSP control may
   occur on a TCP connection while the data flows via UDP. Thus, data
   delivery continues even if no RTSP requests are received by the media



Schulzrinne, et. al.        Standards Track                    [Page 12]

RFC 2326              Real Time Streaming Protocol            April 1998


   server. Also, during its lifetime, a single media stream may be
   controlled by RTSP requests issued sequentially on different TCP
   connections. Therefore, the server needs to maintain "session state"
   to be able to correlate RTSP requests with a stream. The state
   transitions are described in Section A.

   Many methods in RTSP do not contribute to state. However, the
   following play a central role in defining the allocation and usage of
   stream resources on the server: SETUP, PLAY, RECORD, PAUSE, and
   TEARDOWN.

   SETUP:
          Causes the server to allocate resources for a stream and start
          an RTSP session.

   PLAY and RECORD:
          Starts data transmission on a stream allocated via SETUP.

   PAUSE:
          Temporarily halts a stream without freeing server resources.

   TEARDOWN:
          Frees resources associated with the stream. The RTSP session
          ceases to exist on the server.

          RTSP methods that contribute to state use the Session header
          field (Section 12.37) to identify the RTSP session whose state
          is being manipulated. The server generates session identifiers
          in response to SETUP requests (Section 10.4).

1.8 Relationship with Other Protocols

   RTSP has some overlap in functionality with HTTP. It also may
   interact with HTTP in that the initial contact with streaming content
   is often to be made through a web page. The current protocol
   specification aims to allow different hand-off points between a web
   server and the media server implementing RTSP. For example, the
   presentation description can be retrieved using HTTP or RTSP, which
   reduces roundtrips in web-browser-based scenarios, yet also allows
   for standalone RTSP servers and clients which do not rely on HTTP at
   all.

   However, RTSP differs fundamentally from HTTP in that data delivery
   takes place out-of-band in a different protocol. HTTP is an
   asymmetric protocol where the client issues requests and the server
   responds. In RTSP, both the media client and media server can issue
   requests. RTSP requests are also not stateless; they may set
   parameters and continue to control a media stream long after the



Schulzrinne, et. al.        Standards Track                    [Page 13]

RFC 2326              Real Time Streaming Protocol            April 1998


   request has been acknowledged.

     Re-using HTTP functionality has advantages in at least two areas,
     namely security and proxies. The requirements are very similar, so
     having the ability to adopt HTTP work on caches, proxies and
     authentication is valuable.

   While most real-time media will use RTP as a transport protocol, RTSP
   is not tied to RTP.

   RTSP assumes the existence of a presentation description format that
   can express both static and temporal properties of a presentation
   containing several media streams.

2 Notational Conventions

   Since many of the definitions and syntax are identical to HTTP/1.1,
   this specification only points to the section where they are defined
   rather than copying it. For brevity, [HX.Y] is to be taken to refer
   to Section X.Y of the current HTTP/1.1 specification (RFC 2068 [2]).

   All the mechanisms specified in this document are described in both
   prose and an augmented Backus-Naur form (BNF) similar to that used in
   [H2.1]. It is described in detail in RFC 2234 [17], with the
   difference that this RTSP specification maintains the "1#" notation
   for comma-separated lists.

   In this memo, we use indented and smaller-type paragraphs to provide
   background and motivation. This is intended to give readers who were
   not involved with the formulation of the specification an
   understanding of why things are the way that they are in RTSP.

3 Protocol Parameters

3.1 RTSP Version

   [H3.1] applies, with HTTP replaced by RTSP.

3.2 RTSP URL

   The "rtsp" and "rtspu" schemes are used to refer to network resources
   via the RTSP protocol. This section defines the scheme-specific
   syntax and semantics for RTSP URLs.

   rtsp_URL  =   ( "rtsp:" | "rtspu:" )
                 "//" host [ ":" port ] [ abs_path ]
   host      =   <A legal Internet host domain name of IP address
                 (in dotted decimal form), as defined by Section 2.1



Schulzrinne, et. al.        Standards Track                    [Page 14]

RFC 2326              Real Time Streaming Protocol            April 1998


                 of RFC 1123 \cite{rfc1123}>
   port      =   *DIGIT

   abs_path is defined in [H3.2.1].

     Note that fragment and query identifiers do not have a well-defined
     meaning at this time, with the interpretation left to the RTSP
     server.

   The scheme rtsp requires that commands are issued via a reliable
   protocol (within the Internet, TCP), while the scheme rtspu identifies
   an unreliable protocol (within the Internet, UDP).

   If the port is empty or not given, port 554 is assumed. The semantics
   are that the identified resource can be controlled by RTSP at the
   server listening for TCP (scheme "rtsp") connections or UDP (scheme
   "rtspu") packets on that port of host, and the Request-URI for the
   resource is rtsp_URL.

   The use of IP addresses in URLs SHOULD be avoided whenever possible
   (see RFC 1924 [19]).

   A presentation or a stream is identified by a textual media
   identifier, using the character set and escape conventions [H3.2] of
   URLs (RFC 1738 [20]). URLs may refer to a stream or an aggregate of
   streams, i.e., a presentation. Accordingly, requests described in
   Section 10 can apply to either the whole presentation or an individual
   stream within the presentation. Note that some request methods can
   only be applied to streams, not presentations and vice versa.

   For example, the RTSP URL:
     rtsp://media.example.com:554/twister/audiotrack

   identifies the audio stream within the presentation "twister", which
   can be controlled via RTSP requests issued over a TCP connection to
   port 554 of host media.example.com.

   Also, the RTSP URL:
     rtsp://media.example.com:554/twister

   identifies the presentation "twister", which may be composed of
   audio and video streams.

   This does not imply a standard way to reference streams in URLs.
   The presentation description defines the hierarchical relationships
   in the presentation and the URLs for the individual streams. A
   presentation description may name a stream "a.mov" and the whole
   presentation "b.mov".



Schulzrinne, et. al.        Standards Track                    [Page 15]

RFC 2326              Real Time Streaming Protocol            April 1998


   The path components of the RTSP URL are opaque to the client and do
   not imply any particular file system structure for the server.

     This decoupling also allows presentation descriptions to be used
     with non-RTSP media control protocols simply by replacing the
     scheme in the URL.

3.3 Conference Identifiers

   Conference identifiers are opaque to RTSP and are encoded using
   standard URI encoding methods (i.e., LWS is escaped with %). They can
   contain any octet value. The conference identifier MUST be globally
   unique. For H.323, the conferenceID value is to be used.

 conference-id =   1*xchar

     Conference identifiers are used to allow RTSP sessions to obtain
     parameters from multimedia conferences the media server is
     participating in. These conferences are created by protocols
     outside the scope of this specification, e.g., H.323 [13] or SIP
     [12]. Instead of the RTSP client explicitly providing transport
     information, for example, it asks the media server to use the
     values in the conference description instead.

3.4 Session Identifiers

   Session identifiers are opaque strings of arbitrary length. Linear
   white space must be URL-escaped. A session identifier MUST be chosen
   randomly and MUST be at least eight octets long to make guessing it
   more difficult. (See Section 16.)

     session-id   =   1*( ALPHA | DIGIT | safe )

3.5 SMPTE Relative Timestamps

   A SMPTE relative timestamp expresses time relative to the start of
   the clip. Relative timestamps are expressed as SMPTE time codes for
   frame-level access accuracy. The time code has the format
   hours:minutes:seconds:frames.subframes, with the origin at the start
   of the clip. The default smpte format is "SMPTE 30 drop" format, with
   frame rate is 29.97 frames per second. Other SMPTE codes MAY be
   supported (such as "SMPTE 25") through the use of alternative use of
   "smpte time". For the "frames" field in the time value can assume
   the values 0 through 29. The difference between 30 and 29.97 frames
   per second is handled by dropping the first two frame indices (values
   00 and 01) of every minute, except every tenth minute. If the frame
   value is zero, it may be omitted. Subframes are measured in
   one-hundredth of a frame.



Schulzrinne, et. al.        Standards Track                    [Page 16]

RFC 2326              Real Time Streaming Protocol            April 1998


   smpte-range  =   smpte-type "=" smpte-time "-" [ smpte-time ]
   smpte-type   =   "smpte" | "smpte-30-drop" | "smpte-25"
                                   ; other timecodes may be added
   smpte-time   =   1*2DIGIT ":" 1*2DIGIT ":" 1*2DIGIT [ ":" 1*2DIGIT ]
                       [ "." 1*2DIGIT ]

   Examples:
     smpte=10:12:33:20-
     smpte=10:07:33-
     smpte=10:07:00-10:07:33:05.01
     smpte-25=10:07:00-10:07:33:05.01

3.6 Normal Play Time

   Normal play time (NPT) indicates the stream absolute position
   relative to the beginning of the presentation. The timestamp consists
   of a decimal fraction. The part left of the decimal may be expressed
   in either seconds or hours, minutes, and seconds. The part right of
   the decimal point measures fractions of a second.

   The beginning of a presentation corresponds to 0.0 seconds. Negative
   values are not defined. The special constant now is defined as the
   current instant of a live event. It may be used only for live events.

   NPT is defined as in DSM-CC: "Intuitively, NPT is the clock the
   viewer associates with a program. It is often digitally displayed on
   a VCR. NPT advances normally when in normal play mode (scale = 1),
   advances at a faster rate when in fast scan forward (high positive
   scale ratio), decrements when in scan reverse (high negative scale
   ratio) and is fixed in pause mode. NPT is (logically) equivalent to
   SMPTE time codes." [5]

   npt-range    =   ( npt-time "-" [ npt-time ] ) | ( "-" npt-time )
   npt-time     =   "now" | npt-sec | npt-hhmmss
   npt-sec      =   1*DIGIT [ "." *DIGIT ]
   npt-hhmmss   =   npt-hh ":" npt-mm ":" npt-ss [ "." *DIGIT ]
   npt-hh       =   1*DIGIT     ; any positive number
   npt-mm       =   1*2DIGIT    ; 0-59
   npt-ss       =   1*2DIGIT    ; 0-59

   Examples:
     npt=123.45-125
     npt=12:05:35.3-
     npt=now-

     The syntax conforms to ISO 8601. The npt-sec notation is optimized
     for automatic generation, the ntp-hhmmss notation for consumption
     by human readers. The "now" constant allows clients to request to



Schulzrinne, et. al.        Standards Track                    [Page 17]

RFC 2326              Real Time Streaming Protocol            April 1998


     receive the live feed rather than the stored or time-delayed
     version. This is needed since neither absolute time nor zero time
     are appropriate for this case.

3.7 Absolute Time

     Absolute time is expressed as ISO 8601 timestamps, using UTC (GMT).
     Fractions of a second may be indicated.

     utc-range    =   "clock" "=" utc-time "-" [ utc-time ]
     utc-time     =   utc-date "T" utc-time "Z"
     utc-date     =   8DIGIT                    ; < YYYYMMDD >
     utc-time     =   6DIGIT [ "." fraction ]   ; < HHMMSS.fraction >

     Example for November 8, 1996 at 14h37 and 20 and a quarter seconds
     UTC:

     19961108T143720.25Z

3.8 Option Tags

   Option tags are unique identifiers used to designate new options in
   RTSP. These tags are used in Require (Section 12.32) and Proxy-
   Require (Section 12.27) header fields.

   Syntax:

     option-tag   =   1*xchar

   The creator of a new RTSP option should either prefix the option with
   a reverse domain name (e.g., "com.foo.mynewfeature" is an apt name
   for a feature whose inventor can be reached at "foo.com"), or
   register the new option with the Internet Assigned Numbers Authority
   (IANA).

3.8.1 Registering New Option Tags with IANA

   When registering a new RTSP option, the following information should
   be provided:

     * Name and description of option. The name may be of any length,
       but SHOULD be no more than twenty characters long. The name MUST
       not contain any spaces, control characters or periods.
     * Indication of who has change control over the option (for
       example, IETF, ISO, ITU-T, other international standardization
       bodies, a consortium or a particular company or group of
       companies);




Schulzrinne, et. al.        Standards Track                    [Page 18]

RFC 2326              Real Time Streaming Protocol            April 1998


     * A reference to a further description, if available, for example
       (in order of preference) an RFC, a published paper, a patent
       filing, a technical report, documented source code or a computer
       manual;
     * For proprietary options, contact information (postal and email
       address);

4 RTSP Message

   RTSP is a text-based protocol and uses the ISO 10646 character set in
   UTF-8 encoding (RFC 2279 [21]). Lines are terminated by CRLF, but
   receivers should be prepared to also interpret CR and LF by
   themselves as line terminators.

     Text-based protocols make it easier to add optional parameters in a
     self-describing manner. Since the number of parameters and the
     frequency of commands is low, processing efficiency is not a
     concern. Text-based protocols, if done carefully, also allow easy
     implementation of research prototypes in scripting languages such
     as Tcl, Visual Basic and Perl.

     The 10646 character set avoids tricky character set switching, but
     is invisible to the application as long as US-ASCII is being used.
     This is also the encoding used for RTCP. ISO 8859-1 translates
     directly into Unicode with a high-order octet of zero. ISO 8859-1
     characters with the most-significant bit set are represented as
     1100001x 10xxxxxx. (See RFC 2279 [21])

   RTSP messages can be carried over any lower-layer transport protocol
   that is 8-bit clean.

   Requests contain methods, the object the method is operating upon and
   parameters to further describe the method. Methods are idempotent,
   unless otherwise noted. Methods are also designed to require little
   or no state maintenance at the media server.

4.1 Message Types

   See [H4.1]

4.2 Message Headers

   See [H4.2]

4.3 Message Body

   See [H4.3]




Schulzrinne, et. al.        Standards Track                    [Page 19]

RFC 2326              Real Time Streaming Protocol            April 1998


4.4 Message Length

   When a message body is included with a message, the length of that
   body is determined by one of the following (in order of precedence):

   1.     Any response message which MUST NOT include a message body
          (such as the 1xx, 204, and 304 responses) is always terminated
          by the first empty line after the header fields, regardless of
          the entity-header fields present in the message. (Note: An
          empty line consists of only CRLF.)

   2.     If a Content-Length header field (section 12.14) is present,
          its value in bytes represents the length of the message-body.
          If this header field is not present, a value of zero is
          assumed.

   3.     By the server closing the connection. (Closing the connection
          cannot be used to indicate the end of a request body, since
          that would leave no possibility for the server to send back a
          response.)

   Note that RTSP does not (at present) support the HTTP/1.1 "chunked"
   transfer coding(see [H3.6]) and requires the presence of the
   Content-Length header field.

     Given the moderate length of presentation descriptions returned,
     the server should always be able to determine its length, even if
     it is generated dynamically, making the chunked transfer encoding
     unnecessary. Even though Content-Length must be present if there is
     any entity body, the rules ensure reasonable behavior even if the
     length is not given explicitly.

5 General Header Fields

   See [H4.5], except that Pragma, Transfer-Encoding and Upgrade headers
   are not defined:

      general-header     =     Cache-Control     ; Section 12.8
                         |     Connection        ; Section 12.10
                         |     Date              ; Section 12.18
                         |     Via               ; Section 12.43

6 Request

   A request message from a client to a server or vice versa includes,
   within the first line of that message, the method to be applied to
   the resource, the identifier of the resource, and the protocol
   version in use.



Schulzrinne, et. al.        Standards Track                    [Page 20]

RFC 2326              Real Time Streaming Protocol            April 1998


       Request      =       Request-Line          ; Section 6.1
                    *(      general-header        ; Section 5
                    |       request-header        ; Section 6.2
                    |       entity-header )       ; Section 8.1
                            CRLF
                            [ message-body ]      ; Section 4.3

6.1 Request Line

  Request-Line = Method SP Request-URI SP RTSP-Version CRLF

   Method         =         "DESCRIBE"              ; Section 10.2
                  |         "ANNOUNCE"              ; Section 10.3
                  |         "GET_PARAMETER"         ; Section 10.8
                  |         "OPTIONS"               ; Section 10.1
                  |         "PAUSE"                 ; Section 10.6
                  |         "PLAY"                  ; Section 10.5
                  |         "RECORD"                ; Section 10.11
                  |         "REDIRECT"              ; Section 10.10
                  |         "SETUP"                 ; Section 10.4
                  |         "SET_PARAMETER"         ; Section 10.9
                  |         "TEARDOWN"              ; Section 10.7
                  |         extension-method

  extension-method = token

  Request-URI = "*" | absolute_URI

  RTSP-Version = "RTSP" "/" 1*DIGIT "." 1*DIGIT

6.2 Request Header Fields

  request-header  =          Accept                   ; Section 12.1
                  |          Accept-Encoding          ; Section 12.2
                  |          Accept-Language          ; Section 12.3
                  |          Authorization            ; Section 12.5
                  |          From                     ; Section 12.20
                  |          If-Modified-Since        ; Section 12.23
                  |          Range                    ; Section 12.29
                  |          Referer                  ; Section 12.30
                  |          User-Agent               ; Section 12.41

   Note that in contrast to HTTP/1.1 [2], RTSP requests always contain
   the absolute URL (that is, including the scheme, host and port)
   rather than just the absolute path.






Schulzrinne, et. al.        Standards Track                    [Page 21]

RFC 2326              Real Time Streaming Protocol            April 1998


     HTTP/1.1 requires servers to understand the absolute URL, but
     clients are supposed to use the Host request header. This is purely
     needed for backward-compatibility with HTTP/1.0 servers, a
     consideration that does not apply to RTSP.

   The asterisk "*" in the Request-URI means that the request does not
   apply to a particular resource, but to the server itself, and is only
   allowed when the method used does not necessarily apply to a
   resource.  One example would be:

     OPTIONS * RTSP/1.0

7 Response

   [H6] applies except that HTTP-Version is replaced by RTSP-Version.
   Also, RTSP defines additional status codes and does not define some
   HTTP codes. The valid response codes and the methods they can be used
   with are defined in Table 1.

   After receiving and interpreting a request message, the recipient
   responds with an RTSP response message.

     Response    =     Status-Line         ; Section 7.1
                 *(    general-header      ; Section 5
                 |     response-header     ; Section 7.1.2
                 |     entity-header )     ; Section 8.1
                       CRLF
                       [ message-body ]    ; Section 4.3

7.1 Status-Line

   The first line of a Response message is the Status-Line, consisting
   of the protocol version followed by a numeric status code, and the
   textual phrase associated with the status code, with each element
   separated by SP characters. No CR or LF is allowed except in the
   final CRLF sequence.

   Status-Line =   RTSP-Version SP Status-Code SP Reason-Phrase CRLF

7.1.1 Status Code and Reason Phrase

   The Status-Code element is a 3-digit integer result code of the
   attempt to understand and satisfy the request. These codes are fully
   defined in Section 11. The Reason-Phrase is intended to give a short
   textual description of the Status-Code. The Status-Code is intended
   for use by automata and the Reason-Phrase is intended for the human
   user. The client is not required to examine or display the Reason-
   Phrase.



Schulzrinne, et. al.        Standards Track                    [Page 22]

RFC 2326              Real Time Streaming Protocol            April 1998


   The first digit of the Status-Code defines the class of response. The
   last two digits do not have any categorization role. There are 5
   values for the first digit:

     * 1xx: Informational - Request received, continuing process
     * 2xx: Success - The action was successfully received, understood,
       and accepted
     * 3xx: Redirection - Further action must be taken in order to
       complete the request
     * 4xx: Client Error - The request contains bad syntax or cannot be
       fulfilled
     * 5xx: Server Error - The server failed to fulfill an apparently
       valid request

   The individual values of the numeric status codes defined for
   RTSP/1.0, and an example set of corresponding Reason-Phrase's, are
   presented below. The reason phrases listed here are only recommended
   - they may be replaced by local equivalents without affecting the
   protocol. Note that RTSP adopts most HTTP/1.1 [2] status codes and
   adds RTSP-specific status codes starting at x50 to avoid conflicts
   with newly defined HTTP status codes.






























Schulzrinne, et. al.        Standards Track                    [Page 23]

RFC 2326              Real Time Streaming Protocol            April 1998


   Status-Code  =     "100"      ; Continue
                |     "200"      ; OK
                |     "201"      ; Created
                |     "250"      ; Low on Storage Space
                |     "300"      ; Multiple Choices
                |     "301"      ; Moved Permanently
                |     "302"      ; Moved Temporarily
                |     "303"      ; See Other
                |     "304"      ; Not Modified
                |     "305"      ; Use Proxy
                |     "400"      ; Bad Request
                |     "401"      ; Unauthorized
                |     "402"      ; Payment Required
                |     "403"      ; Forbidden
                |     "404"      ; Not Found
                |     "405"      ; Method Not Allowed
                |     "406"      ; Not Acceptable
                |     "407"      ; Proxy Authentication Required
                |     "408"      ; Request Time-out
                |     "410"      ; Gone
                |     "411"      ; Length Required
                |     "412"      ; Precondition Failed
                |     "413"      ; Request Entity Too Large
                |     "414"      ; Request-URI Too Large
                |     "415"      ; Unsupported Media Type
                |     "451"      ; Parameter Not Understood
                |     "452"      ; Conference Not Found
                |     "453"      ; Not Enough Bandwidth
                |     "454"      ; Session Not Found
                |     "455"      ; Method Not Valid in This State
                |     "456"      ; Header Field Not Valid for Resource
                |     "457"      ; Invalid Range
                |     "458"      ; Parameter Is Read-Only
                |     "459"      ; Aggregate operation not allowed
                |     "460"      ; Only aggregate operation allowed
                |     "461"      ; Unsupported transport
                |     "462"      ; Destination unreachable
                |     "500"      ; Internal Server Error
                |     "501"      ; Not Implemented
                |     "502"      ; Bad Gateway
                |     "503"      ; Service Unavailable
                |     "504"      ; Gateway Time-out
                |     "505"      ; RTSP Version not supported
                |     "551"      ; Option not supported
                |     extension-code






Schulzrinne, et. al.        Standards Track                    [Page 24]

RFC 2326              Real Time Streaming Protocol            April 1998


   extension-code  =     3DIGIT

   Reason-Phrase  =     *<TEXT, excluding CR, LF>

   RTSP status codes are extensible. RTSP applications are not required
   to understand the meaning of all registered status codes, though such
   understanding is obviously desirable. However, applications MUST
   understand the class of any status code, as indicated by the first
   digit, and treat any unrecognized response as being equivalent to the
   x00 status code of that class, with the exception that an
   unrecognized response MUST NOT be cached. For example, if an
   unrecognized status code of 431 is received by the client, it can
   safely assume that there was something wrong with its request and
   treat the response as if it had received a 400 status code. In such
   cases, user agents SHOULD present to the user the entity returned
   with the response, since that entity is likely to include human-
   readable information which will explain the unusual status.

   Code           reason

   100            Continue                         all

   200            OK                               all
   201            Created                          RECORD
   250            Low on Storage Space             RECORD

   300            Multiple Choices                 all
   301            Moved Permanently                all
   302            Moved Temporarily                all
   303            See Other                        all
   305            Use Proxy                        all




















Schulzrinne, et. al.        Standards Track                    [Page 25]

RFC 2326              Real Time Streaming Protocol            April 1998


   400            Bad Request                      all
   401            Unauthorized                     all
   402            Payment Required                 all
   403            Forbidden                        all
   404            Not Found                        all
   405            Method Not Allowed               all
   406            Not Acceptable                   all
   407            Proxy Authentication Required    all
   408            Request Timeout                  all
   410            Gone                             all
   411            Length Required                  all
   412            Precondition Failed              DESCRIBE, SETUP
   413            Request Entity Too Large         all
   414            Request-URI Too Long             all
   415            Unsupported Media Type           all
   451            Invalid parameter                SETUP
   452            Illegal Conference Identifier    SETUP
   453            Not Enough Bandwidth             SETUP
   454            Session Not Found                all
   455            Method Not Valid In This State   all
   456            Header Field Not Valid           all
   457            Invalid Range                    PLAY
   458            Parameter Is Read-Only           SET_PARAMETER
   459            Aggregate Operation Not Allowed  all
   460            Only Aggregate Operation Allowed all
   461            Unsupported Transport            all
   462            Destination Unreachable          all

   500            Internal Server Error            all
   501            Not Implemented                  all
   502            Bad Gateway                      all
   503            Service Unavailable              all
   504            Gateway Timeout                  all
   505            RTSP Version Not Supported       all
   551            Option not support               all


      Table 1: Status codes and their usage with RTSP methods

7.1.2 Response Header Fields

   The response-header fields allow the request recipient to pass
   additional information about the response which cannot be placed in
   the Status-Line. These header fields give information about the
   server and about further access to the resource identified by the
   Request-URI.





Schulzrinne, et. al.        Standards Track                    [Page 26]

RFC 2326              Real Time Streaming Protocol            April 1998


   response-header  =     Location             ; Section 12.25
                    |     Proxy-Authenticate   ; Section 12.26
                    |     Public               ; Section 12.28
                    |     Retry-After          ; Section 12.31
                    |     Server               ; Section 12.36
                    |     Vary                 ; Section 12.42
                    |     WWW-Authenticate     ; Section 12.44

   Response-header field names can be extended reliably only in
   combination with a change in the protocol version. However, new or
   experimental header fields MAY be given the semantics of response-
   header fields if all parties in the communication recognize them to
   be response-header fields. Unrecognized header fields are treated as
   entity-header fields.

8 Entity

   Request and Response messages MAY transfer an entity if not otherwise
   restricted by the request method or response status code. An entity
   consists of entity-header fields and an entity-body, although some
   responses will only include the entity-headers.

   In this section, both sender and recipient refer to either the client
   or the server, depending on who sends and who receives the entity.

8.1 Entity Header Fields

   Entity-header fields define optional metainformation about the
   entity-body or, if no body is present, about the resource identified
   by the request.

     entity-header       =    Allow               ; Section 12.4
                         |    Content-Base        ; Section 12.11
                         |    Content-Encoding    ; Section 12.12
                         |    Content-Language    ; Section 12.13
                         |    Content-Length      ; Section 12.14
                         |    Content-Location    ; Section 12.15
                         |    Content-Type        ; Section 12.16
                         |    Expires             ; Section 12.19
                         |    Last-Modified       ; Section 12.24
                         |    extension-header
     extension-header    =    message-header

   The extension-header mechanism allows additional entity-header fields
   to be defined without changing the protocol, but these fields cannot
   be assumed to be recognizable by the recipient. Unrecognized header
   fields SHOULD be ignored by the recipient and forwarded by proxies.




Schulzrinne, et. al.        Standards Track                    [Page 27]

RFC 2326              Real Time Streaming Protocol            April 1998


8.2 Entity Body

   See [H7.2]

9 Connections

   RTSP requests can be transmitted in several different ways:

     * persistent transport connections used for several
       request-response transactions;
     * one connection per request/response transaction;
     * connectionless mode.

   The type of transport connection is defined by the RTSP URI (Section
   3.2). For the scheme "rtsp", a persistent connection is assumed,
   while the scheme "rtspu" calls for RTSP requests to be sent without
   setting up a connection.

   Unlike HTTP, RTSP allows the media server to send requests to the
   media client. However, this is only supported for persistent
   connections, as the media server otherwise has no reliable way of
   reaching the client. Also, this is the only way that requests from
   media server to client are likely to traverse firewalls.

9.1 Pipelining

   A client that supports persistent connections or connectionless mode
   MAY "pipeline" its requests (i.e., send multiple requests without
   waiting for each response). A server MUST send its responses to those
   requests in the same order that the requests were received.

9.2 Reliability and Acknowledgements

   Requests are acknowledged by the receiver unless they are sent to a
   multicast group. If there is no acknowledgement, the sender may
   resend the same message after a timeout of one round-trip time (RTT).
   The round-trip time is estimated as in TCP (RFC 1123) [18], with an
   initial round-trip value of 500 ms. An implementation MAY cache the
   last RTT measurement as the initial value for future connections.

   If a reliable transport protocol is used to carry RTSP, requests MUST
   NOT be retransmitted; the RTSP application MUST instead rely on the
   underlying transport to provide reliability.

     If both the underlying reliable transport such as TCP and the RTSP
     application retransmit requests, it is possible that each packet
     loss results in two retransmissions. The receiver cannot typically
     take advantage of the application-layer retransmission since the



Schulzrinne, et. al.        Standards Track                    [Page 28]

RFC 2326              Real Time Streaming Protocol            April 1998


     transport stack will not deliver the application-layer
     retransmission before the first attempt has reached the receiver.
     If the packet loss is caused by congestion, multiple
     retransmissions at different layers will exacerbate the congestion.

     If RTSP is used over a small-RTT LAN, standard procedures for
     optimizing initial TCP round trip estimates, such as those used in
     T/TCP (RFC 1644) [22], can be beneficial.

   The Timestamp header (Section 12.38) is used to avoid the
   retransmission ambiguity problem [23, p. 301] and obviates the need
   for Karn's algorithm.

   Each request carries a sequence number in the CSeq header (Section
   12.17), which is incremented by one for each distinct request
   transmitted. If a request is repeated because of lack of
   acknowledgement, the request MUST carry the original sequence number
   (i.e., the sequence number is not incremented).

   Systems implementing RTSP MUST support carrying RTSP over TCP and MAY
   support UDP. The default port for the RTSP server is 554 for both UDP
   and TCP.

   A number of RTSP packets destined for the same control end point may
   be packed into a single lower-layer PDU or encapsulated into a TCP
   stream. RTSP data MAY be interleaved with RTP and RTCP packets.
   Unlike HTTP, an RTSP message MUST contain a Content-Length header
   whenever that message contains a payload. Otherwise, an RTSP packet
   is terminated with an empty line immediately following the last
   message header.

10 Method Definitions

   The method token indicates the method to be performed on the resource
   identified by the Request-URI. The method is case-sensitive.  New
   methods may be defined in the future. Method names may not start with
   a $ character (decimal 24) and must be a token. Methods are
   summarized in Table 2.













Schulzrinne, et. al.        Standards Track                    [Page 29]

RFC 2326              Real Time Streaming Protocol            April 1998


      method            direction        object     requirement
      DESCRIBE          C->S             P,S        recommended
      ANNOUNCE          C->S, S->C       P,S        optional
      GET_PARAMETER     C->S, S->C       P,S        optional
      OPTIONS           C->S, S->C       P,S        required
                                                    (S->C: optional)
      PAUSE             C->S             P,S        recommended
      PLAY              C->S             P,S        required
      RECORD            C->S             P,S        optional
      REDIRECT          S->C             P,S        optional
      SETUP             C->S             S          required
      SET_PARAMETER     C->S, S->C       P,S        optional
      TEARDOWN          C->S             P,S        required

      Table 2: Overview of RTSP methods, their direction, and what
      objects (P: presentation, S: stream) they operate on

   Notes on Table 2: PAUSE is recommended, but not required in that a
   fully functional server can be built that does not support this
   method, for example, for live feeds. If a server does not support a
   particular method, it MUST return "501 Not Implemented" and a client
   SHOULD not try this method again for this server.

10.1 OPTIONS

   The behavior is equivalent to that described in [H9.2]. An OPTIONS
   request may be issued at any time, e.g., if the client is about to
   try a nonstandard request. It does not influence server state.

   Example:

     C->S:  OPTIONS * RTSP/1.0
            CSeq: 1
            Require: implicit-play
            Proxy-Require: gzipped-messages

     S->C:  RTSP/1.0 200 OK
            CSeq: 1
            Public: DESCRIBE, SETUP, TEARDOWN, PLAY, PAUSE

   Note that these are necessarily fictional features (one would hope
   that we would not purposefully overlook a truly useful feature just
   so that we could have a strong example in this section).








Schulzrinne, et. al.        Standards Track                    [Page 30]

RFC 2326              Real Time Streaming Protocol            April 1998


10.2 DESCRIBE

   The DESCRIBE method retrieves the description of a presentation or
   media object identified by the request URL from a server. It may use
   the Accept header to specify the description formats that the client
   understands. The server responds with a description of the requested
   resource. The DESCRIBE reply-response pair constitutes the media
   initialization phase of RTSP.

   Example:

     C->S: DESCRIBE rtsp://server.example.com/fizzle/foo RTSP/1.0
           CSeq: 312
           Accept: application/sdp, application/rtsl, application/mheg

     S->C: RTSP/1.0 200 OK
           CSeq: 312
           Date: 23 Jan 1997 15:35:06 GMT
           Content-Type: application/sdp
           Content-Length: 376

           v=0
           o=mhandley 2890844526 2890842807 IN IP4 126.16.64.4
           s=SDP Seminar
           i=A Seminar on the session description protocol
           u=http://www.cs.ucl.ac.uk/staff/M.Handley/sdp.03.ps
           e=mjh@isi.edu (Mark Handley)
           c=IN IP4 224.2.17.12/127
           t=2873397496 2873404696
           a=recvonly
           m=audio 3456 RTP/AVP 0
           m=video 2232 RTP/AVP 31
           m=whiteboard 32416 UDP WB
           a=orient:portrait

   The DESCRIBE response MUST contain all media initialization
   information for the resource(s) that it describes. If a media client
   obtains a presentation description from a source other than DESCRIBE
   and that description contains a complete set of media initialization
   parameters, the client SHOULD use those parameters and not then
   request a description for the same media via RTSP.

   Additionally, servers SHOULD NOT use the DESCRIBE response as a means
   of media indirection.

     Clear ground rules need to be established so that clients have an
     unambiguous means of knowing when to request media initialization
     information via DESCRIBE, and when not to. By forcing a DESCRIBE



Schulzrinne, et. al.        Standards Track                    [Page 31]

RFC 2326              Real Time Streaming Protocol            April 1998


     response to contain all media initialization for the set of streams
     that it describes, and discouraging use of DESCRIBE for media
     indirection, we avoid looping problems that might result from other
     approaches.

     Media initialization is a requirement for any RTSP-based system,
     but the RTSP specification does not dictate that this must be done
     via the DESCRIBE method. There are three ways that an RTSP client
     may receive initialization information:

     * via RTSP's DESCRIBE method;
     * via some other protocol (HTTP, email attachment, etc.);
     * via the command line or standard input (thus working as a browser
       helper application launched with an SDP file or other media
       initialization format).

     In the interest of practical interoperability, it is highly
     recommended that minimal servers support the DESCRIBE method, and
     highly recommended that minimal clients support the ability to act
     as a "helper application" that accepts a media initialization file
     from standard input, command line, and/or other means that are
     appropriate to the operating environment of the client.

10.3 ANNOUNCE

   The ANNOUNCE method serves two purposes:

   When sent from client to server, ANNOUNCE posts the description of a
   presentation or media object identified by the request URL to a
   server. When sent from server to client, ANNOUNCE updates the session
   description in real-time.

   If a new media stream is added to a presentation (e.g., during a live
   presentation), the whole presentation description should be sent
   again, rather than just the additional components, so that components
   can be deleted.

   Example:

     C->S: ANNOUNCE rtsp://server.example.com/fizzle/foo RTSP/1.0
           CSeq: 312
           Date: 23 Jan 1997 15:35:06 GMT
           Session: 47112344
           Content-Type: application/sdp
           Content-Length: 332

           v=0
           o=mhandley 2890844526 2890845468 IN IP4 126.16.64.4



Schulzrinne, et. al.        Standards Track                    [Page 32]

RFC 2326              Real Time Streaming Protocol            April 1998


           s=SDP Seminar
           i=A Seminar on the session description protocol
           u=http://www.cs.ucl.ac.uk/staff/M.Handley/sdp.03.ps
           e=mjh@isi.edu (Mark Handley)
           c=IN IP4 224.2.17.12/127
           t=2873397496 2873404696
           a=recvonly
           m=audio 3456 RTP/AVP 0
           m=video 2232 RTP/AVP 31

     S->C: RTSP/1.0 200 OK
           CSeq: 312

10.4 SETUP

   The SETUP request for a URI specifies the transport mechanism to be
   used for the streamed media. A client can issue a SETUP request for a
   stream that is already playing to change transport parameters, which
   a server MAY allow. If it does not allow this, it MUST respond with
   error "455 Method Not Valid In This State". For the benefit of any
   intervening firewalls, a client must indicate the transport
   parameters even if it has no influence over these parameters, for
   example, where the server advertises a fixed multicast address.

     Since SETUP includes all transport initialization information,
     firewalls and other intermediate network devices (which need this
     information) are spared the more arduous task of parsing the
     DESCRIBE response, which has been reserved for media
     initialization.

   The Transport header specifies the transport parameters acceptable to
   the client for data transmission; the response will contain the
   transport parameters selected by the server.

    C->S: SETUP rtsp://example.com/foo/bar/baz.rm RTSP/1.0
          CSeq: 302
          Transport: RTP/AVP;unicast;client_port=4588-4589

    S->C: RTSP/1.0 200 OK
          CSeq: 302
          Date: 23 Jan 1997 15:35:06 GMT
          Session: 47112344
          Transport: RTP/AVP;unicast;
            client_port=4588-4589;server_port=6256-6257

   The server generates session identifiers in response to SETUP
   requests. If a SETUP request to a server includes a session
   identifier, the server MUST bundle this setup request into the



Schulzrinne, et. al.        Standards Track                    [Page 33]

RFC 2326              Real Time Streaming Protocol            April 1998


   existing session or return error "459 Aggregate Operation Not
   Allowed" (see Section 11.3.10).

10.5 PLAY

   The PLAY method tells the server to start sending data via the
   mechanism specified in SETUP. A client MUST NOT issue a PLAY request
   until any outstanding SETUP requests have been acknowledged as
   successful.

   The PLAY request positions the normal play time to the beginning of
   the range specified and delivers stream data until the end of the
   range is reached. PLAY requests may be pipelined (queued); a server
   MUST queue PLAY requests to be executed in order. That is, a PLAY
   request arriving while a previous PLAY request is still active is
   delayed until the first has been completed.

     This allows precise editing.

   For example, regardless of how closely spaced the two PLAY requests
   in the example below arrive, the server will first play seconds 10
   through 15, then, immediately following, seconds 20 to 25, and
   finally seconds 30 through the end.

     C->S: PLAY rtsp://audio.example.com/audio RTSP/1.0
           CSeq: 835
           Session: 12345678
           Range: npt=10-15

     C->S: PLAY rtsp://audio.example.com/audio RTSP/1.0
           CSeq: 836
           Session: 12345678
           Range: npt=20-25

     C->S: PLAY rtsp://audio.example.com/audio RTSP/1.0
           CSeq: 837
           Session: 12345678
           Range: npt=30-

   See the description of the PAUSE request for further examples.

   A PLAY request without a Range header is legal. It starts playing a
   stream from the beginning unless the stream has been paused. If a
   stream has been paused via PAUSE, stream delivery resumes at the
   pause point. If a stream is playing, such a PLAY request causes no
   further action and can be used by the client to test server liveness.





Schulzrinne, et. al.        Standards Track                    [Page 34]

RFC 2326              Real Time Streaming Protocol            April 1998


   The Range header may also contain a time parameter. This parameter
   specifies a time in UTC at which the playback should start. If the
   message is received after the specified time, playback is started
   immediately. The time parameter may be used to aid in synchronization
   of streams obtained from different sources.

   For a on-demand stream, the server replies with the actual range that
   will be played back. This may differ from the requested range if
   alignment of the requested range to valid frame boundaries is
   required for the media source. If no range is specified in the
   request, the current position is returned in the reply. The unit of
   the range in the reply is the same as that in the request.

   After playing the desired range, the presentation is automatically
   paused, as if a PAUSE request had been issued.

   The following example plays the whole presentation starting at SMPTE
   time code 0:10:20 until the end of the clip. The playback is to start
   at 15:36 on 23 Jan 1997.

     C->S: PLAY rtsp://audio.example.com/twister.en RTSP/1.0
           CSeq: 833
           Session: 12345678
           Range: smpte=0:10:20-;time=19970123T153600Z

     S->C: RTSP/1.0 200 OK
           CSeq: 833
           Date: 23 Jan 1997 15:35:06 GMT
           Range: smpte=0:10:22-;time=19970123T153600Z

   For playing back a recording of a live presentation, it may be
   desirable to use clock units:

     C->S: PLAY rtsp://audio.example.com/meeting.en RTSP/1.0
           CSeq: 835
           Session: 12345678
           Range: clock=19961108T142300Z-19961108T143520Z

     S->C: RTSP/1.0 200 OK
           CSeq: 835
           Date: 23 Jan 1997 15:35:06 GMT

   A media server only supporting playback MUST support the npt format
   and MAY support the clock and smpte formats.







Schulzrinne, et. al.        Standards Track                    [Page 35]

RFC 2326              Real Time Streaming Protocol            April 1998


10.6 PAUSE

   The PAUSE request causes the stream delivery to be interrupted
   (halted) temporarily. If the request URL names a stream, only
   playback and recording of that stream is halted. For example, for
   audio, this is equivalent to muting. If the request URL names a
   presentation or group of streams, delivery of all currently active
   streams within the presentation or group is halted. After resuming
   playback or recording, synchronization of the tracks MUST be
   maintained. Any server resources are kept, though servers MAY close
   the session and free resources after being paused for the duration
   specified with the timeout parameter of the Session header in the
   SETUP message.

   Example:

     C->S: PAUSE rtsp://example.com/fizzle/foo RTSP/1.0
           CSeq: 834
           Session: 12345678

     S->C: RTSP/1.0 200 OK
           CSeq: 834
           Date: 23 Jan 1997 15:35:06 GMT

   The PAUSE request may contain a Range header specifying when the
   stream or presentation is to be halted. We refer to this point as the
   "pause point". The header must contain exactly one value rather than
   a time range. The normal play time for the stream is set to the pause
   point. The pause request becom[H[2Je